{
    "generic_shortest_path_problem_gen0_prog0": {
        "id": "generic_shortest_path_problem_gen0_prog0",
        "code": "def solve_shortest_paths(input_payload):\n    import heapq\n\n    # Parse input: expect [graph, start] or (graph, start), with optional options dict as third item\n    graph = {}\n    start = None\n    options = {}\n    if isinstance(input_payload, (list, tuple)):\n        if len(input_payload) >= 1 and isinstance(input_payload[0], dict):\n            graph = input_payload[0]\n        if len(input_payload) >= 2:\n            start = input_payload[1]\n        if len(input_payload) >= 3 and isinstance(input_payload[2], dict):\n            options = input_payload[2]\n    elif isinstance(input_payload, dict):\n        graph = input_payload\n        start = None\n    else:\n        graph = {}\n        start = None\n\n    if start is None:\n        # Fallback: try to pick an arbitrary start (not specified by problem, but ensure robustness)\n        # If graph is empty, return empty dict\n        if not graph:\n            solve_shortest_paths.diagnostics = {\n                \"note\": \"No start provided and empty graph\",\n                \"node_count\": 0,\n                \"edge_count\": 0,\n            }\n            return {}\n        # Otherwise pick first key as start\n        try:\n            start = next(iter(graph.keys()))\n        except StopIteration:\n            start = None\n\n    # Collect all nodes (keys and implicit nodes from neighbor dictionaries) plus start\n    all_nodes = set()\n    edge_count = 0\n    min_edge_weight = float('inf')\n    for u, nbrs in graph.items():\n        all_nodes.add(u)\n        if isinstance(nbrs, dict):\n            for v, w in nbrs.items():\n                all_nodes.add(v)\n                edge_count += 1\n                try:\n                    if w < min_edge_weight:\n                        min_edge_weight = w\n                except TypeError:\n                    # Non-numeric weight; treat as non-negative for safety\n                    pass\n    if start is not None:\n        all_nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in all_nodes}\n    if start is not None:\n        dist[start] = 0\n\n    # Diagnostics container\n    metrics = {\n        \"node_count\": len(all_nodes),\n        \"edge_count\": edge_count,\n        \"has_negative_edge\": min_edge_weight < 0,\n        \"algorithm\": None,\n        \"relaxations\": 0,\n        \"updates\": 0,\n        \"heap_pushes\": 0,\n        \"heap_pops\": 0,\n        \"bellman_ford_passes\": 0,\n        \"early_exit\": False,\n        \"options_used\": {},\n    }\n\n    # Options and tactics\n    algo_choice = options.get(\"algorithm\", \"auto\")  # \"auto\", \"dijkstra\", \"bellman-ford\"\n    neighbor_order = options.get(\"neighbor_order\", \"as_is\")  # \"as_is\", \"asc\", \"desc\", \"random\"\n    randomize = options.get(\"randomize\", False) or neighbor_order == \"random\"\n    seed = options.get(\"seed\", 0)\n    prefer_dense = options.get(\"prefer_dense\", False)  # hint to use Bellman-Ford if dense\n    metrics[\"options_used\"] = {\n        \"algorithm\": algo_choice,\n        \"neighbor_order\": neighbor_order,\n        \"randomize\": randomize,\n        \"seed\": seed,\n        \"prefer_dense\": prefer_dense,\n    }\n\n    # Lightweight PRNG (LCG) for deterministic randomness without importing random\n    class _PRNG:\n        __slots__ = (\"s\",)\n        def __init__(self, s):\n            self.s = int(s) & 0x7fffffff\n        def rand(self):\n            self.s = (1103515245 * self.s + 12345) & 0x7fffffff\n            return self.s\n        def rand_float(self):\n            return self.rand() / 0x7fffffff\n\n    rng = _PRNG(seed)\n\n    def order_neighbors(u_items):\n        # u_items is list of (v, w)\n        if not u_items:\n            return u_items\n        if neighbor_order == \"asc\":\n            return sorted(u_items, key=lambda x: (x[1], x[0]))\n        elif neighbor_order == \"desc\":\n            return sorted(u_items, key=lambda x: (x[1], x[0]), reverse=True)\n        elif randomize:\n            # Deterministic shuffle using LCG-based keys\n            return sorted(u_items, key=lambda x: (rng.rand(), x[0]))\n        else:\n            return u_items\n\n    # Choose algorithm\n    use_bellman_ford = False\n    if algo_choice == \"bellman-ford\":\n        use_bellman_ford = True\n    elif algo_choice == \"dijkstra\":\n        use_bellman_ford = False\n    else:\n        # auto\n        if min_edge_weight < 0:\n            use_bellman_ford = True\n        else:\n            # heuristic: if graph is dense and node_count small, BF might be ok; else Dijkstra\n            n = len(all_nodes)\n            if prefer_dense and n > 0 and edge_count > n * (n - 1) // 4:\n                use_bellman_ford = True\n            else:\n                use_bellman_ford = False\n\n    if use_bellman_ford:\n        metrics[\"algorithm\"] = \"bellman-ford\"\n        # Bellman-Ford: relax all edges |V|-1 times\n        if start is None:\n            # No meaningful start; return distances for nodes (all inf)\n            solve_shortest_paths.diagnostics = metrics\n            return dist\n        V = len(all_nodes)\n        for i in range(max(V - 1, 0)):\n            updated = False\n            for u in all_nodes:\n                du = dist[u]\n                if du == float('inf'):\n                    continue\n                nbrs = graph.get(u, {})\n                # Convert to list to allow ordering if specified\n                items = list(nbrs.items())\n                items = order_neighbors(items)\n                for v, w in items:\n                    metrics[\"relaxations\"] += 1\n                    try:\n                        nd = du + w\n                    except TypeError:\n                        # Non-numeric; skip\n                        continue\n                    if nd < dist[v]:\n                        dist[v] = nd\n                        updated = True\n                        metrics[\"updates\"] += 1\n            metrics[\"bellman_ford_passes\"] += 1\n            if not updated:\n                metrics[\"early_exit\"] = True\n                break\n        # We do not detect negative cycles; distances remain as-is\n    else:\n        metrics[\"algorithm\"] = \"dijkstra\"\n        if start is None:\n            # No start; return distances for nodes (all inf)\n            solve_shortest_paths.diagnostics = metrics\n            return dist\n        # Dijkstra with heap; use a monotonic index to break ties safely across mixed-type node ids\n        heap = []\n        push_index = 0\n        heapq.heappush(heap, (0, push_index, start))\n        metrics[\"heap_pushes\"] += 1\n        visited = set()\n        while heap:\n            d_u, _, u = heapq.heappop(heap)\n            metrics[\"heap_pops\"] += 1\n            if d_u != dist[u]:\n                continue\n            if u in visited:\n                continue\n            visited.add(u)\n            nbrs = graph.get(u, {})\n            items = order_neighbors(list(nbrs.items()))\n            for v, w in items:\n                metrics[\"relaxations\"] += 1\n                try:\n                    nd = d_u + w\n                except TypeError:\n                    # Non-numeric; skip this edge\n                    continue\n                if nd < dist[v]:\n                    dist[v] = nd\n                    metrics[\"updates\"] += 1\n                    push_index += 1\n                    heapq.heappush(heap, (nd, push_index, v))\n                    metrics[\"heap_pushes\"] += 1\n\n    # Ensure all nodes present in output, including those only implicit and the start node\n    # Distances for unreachable remain float('inf'), start is 0\n    # Attach diagnostics for downstream evaluators\n    try:\n        solve_shortest_paths.diagnostics = metrics\n    except Exception:\n        pass\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395606.053973,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "systems_builder"
    },
    "generic_shortest_path_problem_gen0_prog1": {
        "id": "generic_shortest_path_problem_gen0_prog1",
        "code": "def solve_shortest_paths(args):\n    \"\"\"\n    solve_shortest_paths(graph_and_start)\n    \n    Key constraints restated:\n    - Search loops: Use Dijkstra's algorithm with a priority queue, discard stale entries to prevent unnecessary loops.\n    - Random seed management: No randomness is used; algorithm is deterministic.\n    - Telemetry capture: Internal counters (e.g., relaxations, pops) can be added if needed but are not returned here.\n    - Reproducibility safeguards: Priority queue uses a monotonically increasing counter to avoid comparing heterogeneous node IDs during ties.\n    \"\"\"\n    import heapq\n\n    graph, start = args\n    # Gather all nodes: keys of graph and any neighbor keys present in inner dicts.\n    all_nodes = set(graph.keys())\n    for u in graph:\n        all_nodes.update(graph[u].keys())\n    # Ensure start node is present in the node set even if graph is empty.\n    all_nodes.add(start)\n\n    # Initialize distances with infinity; start node distance is zero.\n    inf = float('inf')\n    dist = {node: inf for node in all_nodes}\n    dist[start] = 0\n\n    # Priority queue of (distance, counter, node) to avoid comparing node IDs directly.\n    # This ensures deterministic behavior even with mixed-type node identifiers.\n    heap = []\n    counter = 0\n    heapq.heappush(heap, (0, counter, start))\n    counter += 1\n\n    # Dijkstra's algorithm\n    while heap:\n        d_u, _, u = heapq.heappop(heap)\n        # Skip if this entry is stale\n        if d_u != dist[u]:\n            continue\n        # Explore neighbors; nodes without outgoing edges default to empty dict\n        for v, w in graph.get(u, {}).items():\n            # Relaxation step\n            new_dist = d_u + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(heap, (new_dist, counter, v))\n                counter += 1\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395606.0571454,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "systems_builder"
    },
    "generic_shortest_path_problem_gen0_prog2": {
        "id": "generic_shortest_path_problem_gen0_prog2",
        "code": "def solve_shortest_paths(inp):\n    import heapq\n\n    # Parse input\n    if not (isinstance(inp, (list, tuple)) and len(inp) == 2):\n        raise ValueError(\"Input must be a list or tuple of [graph, start_node]\")\n    graph, start = inp\n\n    # Configuration knobs and resource budgets\n    class Config:\n        use_pop_budget = False\n        max_heap_pops = None  # None means unlimited\n\n    # Lightweight logger/statistics\n    class Stats:\n        def __init__(self):\n            self.heap_pushes = 0\n            self.heap_pops = 0\n            self.relaxations = 0\n            self.nodes_processed = 0\n\n    stats = Stats()\n\n    # Collect all nodes: explicit keys + implicit neighbors + start\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Dijkstra's algorithm\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    stats.heap_pushes += 1\n\n    visited = set()\n\n    while heap:\n        if Config.use_pop_budget and Config.max_heap_pops is not None and stats.heap_pops >= Config.max_heap_pops:\n            break\n\n        d_u, u = heapq.heappop(heap)\n        stats.heap_pops += 1\n\n        if d_u != dist[u]:\n            continue  # stale entry\n\n        if u in visited:\n            continue\n        visited.add(u)\n        stats.nodes_processed += 1\n\n        for v, w in graph.get(u, {}).items():\n            alt = d_u + w\n            if alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(heap, (alt, v))\n                stats.heap_pushes += 1\n                stats.relaxations += 1\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395606.0599632,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "systems_builder"
    },
    "generic_shortest_path_problem_gen0_prog3": {
        "id": "generic_shortest_path_problem_gen0_prog3",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n    # Unpack inputs with optional config\n    if isinstance(input_data, (list, tuple)) and len(input_data) >= 2:\n        graph = input_data[0] if input_data[0] is not None else {}\n        start = input_data[1]\n        cfg_in = input_data[2] if len(input_data) > 2 and isinstance(input_data[2], dict) else {}\n    else:\n        graph = {}\n        start = None\n        cfg_in = {}\n\n    # Configuration knobs and resource budgets\n    config = {\n        \"log_enabled\": False,\n        \"max_expansions\": None,     # Max node pops to expand\n        \"max_relaxations\": None     # Max successful edge relaxations\n    }\n    config.update({k: v for k, v in cfg_in.items() if k in config and v is not None})\n\n    # Lightweight logger\n    def make_logger(enabled=False):\n        logs = []\n        def log(event, **kwargs):\n            if enabled:\n                logs.append((event, kwargs))\n        return log\n    log = make_logger(config[\"log_enabled\"])\n\n    # Normalize graph\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Gather all nodes, including implicit ones and the start node\n    all_nodes = set()\n    for u, nbrs in graph.items():\n        all_nodes.add(u)\n        if isinstance(nbrs, dict):\n            all_nodes.update(nbrs.keys())\n    if start is not None:\n        all_nodes.add(start)\n\n    # If no start provided, there's nothing meaningful to compute\n    if start is None:\n        return {}\n\n    # Distances initialization\n    INF = float('inf')\n    dist = {node: INF for node in all_nodes}\n    dist[start] = 0\n\n    # Neighbor access with simple caching\n    neighbors_cache = {}\n    def get_neighbors(u):\n        if u in neighbors_cache:\n            return neighbors_cache[u]\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        neighbors_cache[u] = nbrs\n        return nbrs\n\n    # Dijkstra's algorithm with heap\n    heap = [(0, start)]\n    settled = set()\n\n    expansions = 0\n    relaxations = 0\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        if u not in settled:\n            settled.add(u)\n        # Resource budget: expansions\n        if config[\"max_expansions\"] is not None and expansions >= config[\"max_expansions\"]:\n            break\n        expansions += 1\n\n        for v, w in get_neighbors(u).items():\n            try:\n                new_d = d + w\n            except Exception:\n                # Skip edges with invalid weights\n                continue\n            if new_d < dist[v]:\n                # Resource budget: relaxations\n                if config[\"max_relaxations\"] is not None and relaxations >= config[\"max_relaxations\"]:\n                    continue\n                dist[v] = new_d\n                relaxations += 1\n                heapq.heappush(heap, (new_d, v))\n\n    # Ensure all nodes present; if graph was empty, at least include start\n    if start not in dist:\n        dist[start] = 0\n\n    # Log final stats (kept internal)\n    log(\"done\", expansions=expansions, relaxations=relaxations, settled=len(settled))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395606.0627463,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "systems_builder"
    },
    "generic_shortest_path_problem_gen0_prog4": {
        "id": "generic_shortest_path_problem_gen0_prog4",
        "code": "def solve_shortest_paths(args):\n    \"\"\"\n    Key constraints and safeguards:\n    - Search loops: Use Dijkstra's algorithm with a priority queue and stale-entry skipping to ensure termination.\n    - Random seed management: No randomness is used; algorithm is fully deterministic.\n    - Telemetry capture: Not required; minimal internal counters only if needed (not returned).\n    - Reproducibility safeguards: Pure function behavior; no side effects, deterministic ordering via heapq.\n    \"\"\"\n    import heapq\n\n    # Parse inputs\n    graph = {}\n    start = None\n    if isinstance(args, (list, tuple)) and len(args) == 2:\n        graph, start = args\n    else:\n        # Fallback: try to interpret args as (graph, start)\n        try:\n            graph, start = args  # Unpack if args is an iterable of length 2\n        except Exception:\n            # As last resort, treat args as graph with missing start (undefined behavior),\n            # but to adhere to spec we set start to a default unique object; return only that if empty.\n            graph = args if isinstance(args, dict) else {}\n            start = next(iter(graph), None)\n\n    if graph is None:\n        graph = {}\n    # Ensure start exists; if still None (no nodes at all), define a placeholder None as start\n    # but to keep hashability, we allow None as a key.\n    # The examples assume a concrete start; if not provided, we still return {start: 0}.\n    # This aligns with the pattern: when graph is empty, return {start: 0}.\n    # If start is not provided at all, we keep None.\n    # Build the full node set including implicit nodes and the start.\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u in graph:\n            nbrs = graph.get(u, {})\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    if start is not None:\n        nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    if start is None:\n        # No start provided and graph had no nodes: define start as None and return {None: 0}\n        # But ensure consistent behavior per examples: if graph is empty and start given, return {start:0}\n        # Here start is None; set distance for None.\n        dist = {None: 0.0}\n        return dist\n\n    dist[start] = 0.0\n\n    # Priority queue: (distance, node)\n    heap = [(0.0, start)]\n    # Dijkstra's algorithm\n    while heap:\n        d_u, u = heapq.heappop(heap)\n        # Skip stale entries\n        if d_u != dist.get(u, float('inf')):\n            continue\n        # Explore neighbors; handle nodes possibly missing in graph by using empty dict\n        for v, w in graph.get(u, {}).items():\n            # Assume non-negative weights as per typical Dijkstra prerequisites.\n            nd = d_u + float(w)\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Ensure all nodes encountered implicitly are present in the output\n    for node in nodes:\n        if node not in dist:\n            dist[node] = float('inf')\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395606.0655541,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "systems_builder"
    },
    "generic_shortest_path_problem_gen1_child0_0": {
        "id": "generic_shortest_path_problem_gen1_child0_0",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n        # Unpack inputs with optional config\n    graph = {}\n    start = None\n    cfg_in = {}\n\n    if isinstance(input_data, (list, tuple)) and len(input_data) >= 2:\n        graph = input_data[0] if input_data[0] is not None else {}\n        start = input_data[1]\n        cfg_in = input_data[2] if len(input_data) > 2 and isinstance(input_data[2], dict) else {}\n    elif isinstance(input_data, dict):\n        if 'graph' in input_data and 'start' in input_data:\n            graph = input_data.get('graph') or {}\n            start = input_data.get('start')\n            cfg_in = input_data.get('config') if isinstance(input_data.get('config'), dict) else {}\n        else:\n            # If the dict looks like a graph adjacency mapping, accept it directly\n            looks_like_graph = all(isinstance(v, dict) for v in input_data.values()) if input_data else True\n            if looks_like_graph:\n                graph = input_data\n            else:\n                graph = {}\n            # Try common keys for start if provided\n            for k in ('start', 'source', 'begin', 'root'):\n                if k in input_data and start is None:\n                    start = input_data[k]\n            # Config could be under 'config'\n            if isinstance(input_data.get('config'), dict):\n                cfg_in = input_data['config']\n    else:\n        graph = {}\n        start = None\n        cfg_in = {}\n\n    # Configuration knobs and resource budgets\n    config = {\n        \"log_enabled\": False,\n        \"max_expansions\": None,     # Max node pops to expand\n        \"max_relaxations\": None     # Max successful edge relaxations\n    }\n    config.update({k: v for k, v in cfg_in.items() if k in config and v is not None})\n\n    # Lightweight logger\n    def make_logger(enabled=False):\n        logs = []\n        def log(event, **kwargs):\n            if enabled:\n                logs.append((event, kwargs))\n        return log\n    log = make_logger(config[\"log_enabled\"])\n\n    # Normalize graph\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Gather all nodes, including implicit ones and the start node\n    all_nodes = set()\n    for u, nbrs in graph.items():\n        all_nodes.add(u)\n        if isinstance(nbrs, dict):\n            all_nodes.update(nbrs.keys())\n    if start is not None:\n        all_nodes.add(start)\n\n    # If no start provided, there's nothing meaningful to compute\n    if start is None:\n        return {}\n\n    # Distances initialization\n    INF = float('inf')\n    dist = {node: INF for node in all_nodes}\n    dist[start] = 0\n\n    # Neighbor access with simple caching\n    neighbors_cache = {}\n    def get_neighbors(u):\n        if u in neighbors_cache:\n            return neighbors_cache[u]\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        neighbors_cache[u] = nbrs\n        return nbrs\n\n        # Dijkstra's algorithm with heap, with Bellman-Ford fallback for negative weights\n    heap = [(0, start)]\n    settled = set()\n\n    expansions = 0\n    relaxations = 0\n\n    # Pre-scan edges to decide algorithm\n    edges = []\n    has_negative_weight = False\n    for uu, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            for vv, ww in nbrs.items():\n                if isinstance(ww, (int, float)):\n                    edges.append((uu, vv, ww))\n                    if ww < 0:\n                        has_negative_weight = True\n\n    if has_negative_weight:\n        # Bellman-Ford: relax edges |V|-1 times\n        n_nodes = len(dist)\n        for i in range(n_nodes - 1):\n            updated = False\n            # Resource budget: expansions (count passes)\n            if config[\"max_expansions\"] is not None and expansions >= config[\"max_expansions\"]:\n                break\n            expansions += 1\n            for (u, v, w) in edges:\n                if dist[u] == INF:\n                    continue\n                new_d = dist[u] + w\n                if new_d < dist[v]:\n                    # Resource budget: relaxations\n                    if config[\"max_relaxations\"] is not None and relaxations >= config[\"max_relaxations\"]:\n                        continue\n                    dist[v] = new_d\n                    relaxations += 1\n                    updated = True\n            if not updated:\n                break\n        # No negative cycle handling; distances remain best found\n    else:\n        while heap:\n            d, u = heapq.heappop(heap)\n            if d > dist[u]:\n                continue\n            if u not in settled:\n                settled.add(u)\n            # Resource budget: expansions\n            if config[\"max_expansions\"] is not None and expansions >= config[\"max_expansions\"]:\n                break\n            expansions += 1\n\n            for v, w in get_neighbors(u).items():\n                # Skip edges with invalid or non-finite weights\n                if not isinstance(w, (int, float)):\n                    continue\n                if w != w or w == float('inf') or w == float('-inf'):\n                    continue\n                new_d = d + w\n                if new_d < dist[v]:\n                    # Resource budget: relaxations\n                    if config[\"max_relaxations\"] is not None and relaxations >= config[\"max_relaxations\"]:\n                        continue\n                    dist[v] = new_d\n                    relaxations += 1\n                    heapq.heappush(heap, (new_d, v))\n\n    # Ensure all nodes present; if graph was empty, at least include start\n    if start not in dist:\n        dist[start] = 0\n\n    # Log final stats (kept internal)\n    log(\"done\", expansions=expansions, relaxations=relaxations, settled=len(settled))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog3",
        "island_id": 3,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395866.017071,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen1_child0_1": {
        "id": "generic_shortest_path_problem_gen1_child0_1",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n        # Unpack inputs with optional config\n    if isinstance(input_data, (list, tuple)) and len(input_data) >= 2:\n        graph = input_data[0] if input_data[0] is not None else {}\n        start = input_data[1]\n        cfg_in = input_data[2] if len(input_data) > 2 and isinstance(input_data[2], dict) else {}\n    elif isinstance(input_data, dict) and 'graph' in input_data and 'start' in input_data:\n        graph = input_data.get('graph') or {}\n        start = input_data.get('start')\n        cfg_in = input_data.get('config', {}) if isinstance(input_data.get('config', {}), dict) else {}\n    else:\n        graph = {}\n        start = None\n        cfg_in = {}\n\n    # Configuration knobs and resource budgets\n    config = {\n        \"log_enabled\": False,\n        \"max_expansions\": None,     # Max node pops to expand\n        \"max_relaxations\": None     # Max successful edge relaxations\n    }\n    config.update({k: v for k, v in cfg_in.items() if k in config and v is not None})\n\n    # Lightweight logger\n    def make_logger(enabled=False):\n        logs = []\n        def log(event, **kwargs):\n            if enabled:\n                logs.append((event, kwargs))\n        return log\n    log = make_logger(config[\"log_enabled\"])\n\n    # Normalize graph\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Gather all nodes, including implicit ones and the start node\n    all_nodes = set()\n    for u, nbrs in graph.items():\n        all_nodes.add(u)\n        if isinstance(nbrs, dict):\n            all_nodes.update(nbrs.keys())\n    if start is not None:\n        all_nodes.add(start)\n\n    # If no start provided, there's nothing meaningful to compute\n    if start is None:\n        return {}\n\n    # Distances initialization\n    INF = float('inf')\n    dist = {node: INF for node in all_nodes}\n    dist[start] = 0\n\n    # Neighbor access with simple caching\n    neighbors_cache = {}\n    def get_neighbors(u):\n        if u in neighbors_cache:\n            return neighbors_cache[u]\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        neighbors_cache[u] = nbrs\n        return nbrs\n\n        # Dijkstra's algorithm with heap\n    counter = 0\n    heap = [(0, counter, start)]\n    settled = set()\n\n    expansions = 0\n    relaxations = 0\n\n    while heap:\n        d, _, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        # Skip re-expanding nodes already settled\n        if u in settled:\n            continue\n        # Mark as settled\n        settled.add(u)\n        # Resource budget: expansions\n        if config[\"max_expansions\"] is not None and expansions >= config[\"max_expansions\"]:\n            break\n        expansions += 1\n\n        for v, w in get_neighbors(u).items():\n            # Validate edge weight is numeric and finite\n            if not isinstance(w, (int, float)):\n                continue\n            new_d = d + w\n            # Skip non-finite distances\n            if not (-INF < w < INF) or not (-INF < new_d < INF):\n                continue\n            if new_d < dist[v]:\n                # Resource budget: relaxations\n                if config[\"max_relaxations\"] is not None and relaxations >= config[\"max_relaxations\"]:\n                    continue\n                dist[v] = new_d\n                relaxations += 1\n                counter += 1\n                heapq.heappush(heap, (new_d, counter, v))\n\n    # Ensure all nodes present; if graph was empty, at least include start\n    if start not in dist:\n        dist[start] = 0\n\n    # Log final stats (kept internal)\n    log(\"done\", expansions=expansions, relaxations=relaxations, settled=len(settled))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog3",
        "island_id": 3,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395791.0769322,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen1_child0_2": {
        "id": "generic_shortest_path_problem_gen1_child0_2",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set()\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        nodes.add(u)\n        for v in nbrs.keys():\n            nodes.add(v)\n    nodes.add(start)\n\n    adj = {node: {} for node in nodes}\n    for u, nbrs in graph.items():\n        for v, w in nbrs.items():\n            adj[u][v] = w\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n    pq = [(0.0, start)]\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u].items():\n            try:\n                nd = d + w\n            except TypeError:\n                return None\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n        result = {}\n    for node in nodes:\n        d = dist[node]\n        if d == float('inf'):\n            result[node] = float('inf')\n        else:\n            if isinstance(d, float) and d.is_integer():\n                result[node] = int(d)\n            else:\n                result[node] = d\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1762888959.5796878,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen1_child1_0": {
        "id": "generic_shortest_path_problem_gen1_child1_0",
        "code": "def solve_shortest_paths(args):\n    \"\"\"\n    solve_shortest_paths(graph_and_start)\n    \n    Key constraints restated:\n    - Search loops: Use Dijkstra's algorithm with a priority queue, discard stale entries to prevent unnecessary loops.\n    - Random seed management: No randomness is used; algorithm is deterministic.\n    - Telemetry capture: Internal counters (e.g., relaxations, pops) can be added if needed but are not returned here.\n    - Reproducibility safeguards: Priority queue uses a monotonically increasing counter to avoid comparing heterogeneous node IDs during ties.\n    \"\"\"\n    import heapq\n\n        # Robust argument parsing: support (graph, start) tuple/list or {'graph': ..., 'start': ...} dict\n    if isinstance(args, dict):\n        graph = args.get('graph', {}) or {}\n        start = args.get('start')\n    elif isinstance(args, (list, tuple)) and len(args) == 2:\n        graph, start = args\n    else:\n        # Fallback: assume args is (graph, start)\n        graph, start = args\n    # Targeted assert to help reproduction: start must be provided\n    assert start is not None, \"solve_shortest_paths: 'start' node must be specified\"\n    assert isinstance(graph, dict), f\"solve_shortest_paths: 'graph' must be dict of dicts; got {type(graph)}\"\n\n    # Gather all nodes: keys of graph and any neighbor keys present in inner dicts.\n    all_nodes = set(graph.keys())\n    for u in graph:\n        all_nodes.update(graph[u].keys())\n    # Ensure start node is present in the node set even if graph is empty.\n    all_nodes.add(start)\n\n        # Initialize distances with infinity; start node distance is zero.\n    inf = float('inf')\n    dist = {node: inf for node in all_nodes}\n    dist[start] = 0\n\n    # Detect negative edge weights; Dijkstra requires non-negative weights.\n    has_negative = False\n    for u in graph:\n        for v, w in graph.get(u, {}).items():\n            if w < 0:\n                has_negative = True\n                # Causal path log: negative weight invalidates Dijkstra's correctness\n                print(f\"solve_shortest_paths: negative edge detected {u} -> {v} with weight {w}; switching to Bellman-Ford\")\n                break\n        if has_negative:\n            break\n\n    if has_negative:\n        # Bellman-Ford fallback for graphs with negative weights\n        # Build edge list\n        edges = []\n        for u in all_nodes:\n            for v, w in graph.get(u, {}).items():\n                edges.append((u, v, w))\n        # Relax edges up to |V|-1 times\n        for _ in range(max(0, len(all_nodes) - 1)):\n            updated = False\n            for u, v, w in edges:\n                if dist[u] != inf and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    updated = True\n            if not updated:\n                break\n        return dist\n\n    # Priority queue of (distance, counter, node) to avoid comparing node IDs directly.\n    # This ensures deterministic behavior even with mixed-type node identifiers.\n    heap = []\n    counter = 0\n    heapq.heappush(heap, (0, counter, start))\n    counter += 1\n\n    # Dijkstra's algorithm\n    while heap:\n        d_u, _, u = heapq.heappop(heap)\n        # Skip if this entry is stale\n        if d_u != dist[u]:\n            continue\n        # Explore neighbors; nodes without outgoing edges default to empty dict\n        for v, w in graph.get(u, {}).items():\n            # Relaxation step\n            new_dist = d_u + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(heap, (new_dist, counter, v))\n                counter += 1\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395791.900028,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen1_child1_1": {
        "id": "generic_shortest_path_problem_gen1_child1_1",
        "code": "def solve_shortest_paths(args):\n    \"\"\"\n    solve_shortest_paths(graph_and_start)\n\n    Robust argument parsing:\n    - Accepts (graph, start) tuple/list, or dict with keys 'graph' and 'start'.\n\n    Algorithm:\n    - Uses Dijkstra's algorithm with a priority queue for non-negative weights.\n    - Falls back to Bellman-Ford when any negative edge weight is detected.\n    - Discards stale entries in the priority queue to avoid unnecessary processing.\n    \"\"\"\n    import heapq\n\n    # Normalize input arguments to (graph, start)\n    graph = None\n    start = None\n    try:\n        if isinstance(args, (tuple, list)):\n            if len(args) >= 2:\n                graph, start = args[0], args[1]\n            elif len(args) == 1 and isinstance(args[0], dict) and 'graph' in args[0] and 'start' in args[0]:\n                graph = args[0].get('graph', {})\n                start = args[0].get('start', None)\n        elif isinstance(args, dict):\n            if 'graph' in args and 'start' in args:\n                graph = args.get('graph', {})\n                start = args.get('start', None)\n            elif len(args) == 2:\n                # As a fallback, if a dict with two values was provided without specific keys\n                # try to unpack values in order\n                values = list(args.values())\n                graph, start = values[0], values[1]\n        else:\n            # Attempt direct unpack\n            graph, start = args\n    except Exception:\n        # If unpacking fails, leave graph/start as None to handle below\n        pass\n\n    # If still not set, try a last-resort unpack attempt\n    if graph is None or start is None:\n        try:\n            graph, start = args\n        except Exception:\n            # Unable to parse arguments; return empty result for stability\n            return {}\n\n    # Ensure graph is a dict; if not, treat as empty\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Gather all nodes: keys of graph and any neighbor keys present in inner structures.\n    all_nodes = set()\n    try:\n        all_nodes.update(graph.keys())\n        for u in graph:\n            neighbors = graph.get(u, {})\n            if isinstance(neighbors, dict):\n                all_nodes.update(neighbors.keys())\n            else:\n                # Support adjacency lists like [(v, w), ...]\n                try:\n                    for item in neighbors:\n                        try:\n                            v, _ = item\n                            all_nodes.add(v)\n                        except Exception:\n                            continue\n                except Exception:\n                    pass\n    except Exception:\n        pass\n\n    # Ensure start node is present in the node set even if graph is empty.\n    all_nodes.add(start)\n\n    # Normalize adjacency into a dict-of-dicts with numeric weights\n    adj = {}\n    for u in all_nodes:\n        raw_neighbors = graph.get(u, {})\n        if isinstance(raw_neighbors, dict):\n            nbrs = {}\n            for v, w in raw_neighbors.items():\n                try:\n                    nbrs[v] = float(w)\n                except Exception:\n                    # Skip non-numeric weight entries defensively\n                    continue\n            adj[u] = nbrs\n        else:\n            # Support list/tuple of (neighbor, weight) pairs\n            nbrs = {}\n            try:\n                for item in raw_neighbors:\n                    try:\n                        v, w = item\n                        nbrs[v] = float(w)\n                    except Exception:\n                        continue\n            except Exception:\n                pass\n            adj[u] = nbrs\n\n    # Detect presence of any negative edge weights\n    has_negative = any(w < 0 for nbrs in adj.values() for w in nbrs.values())\n\n    # Initialize distances with infinity; start node distance is zero.\n    inf = float('inf')\n    dist = {node: inf for node in all_nodes}\n    dist[start] = 0.0\n\n    if has_negative:\n        # Bellman-Ford algorithm for graphs with negative weights (no negative cycle handling)\n        edges = []\n        for u, nbrs in adj.items():\n            for v, w in nbrs.items():\n                edges.append((u, v, w))\n\n        n = len(all_nodes)\n        for _ in range(max(0, n - 1)):\n            updated = False\n            for u, v, w in edges:\n                if dist[u] != inf and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    updated = True\n            if not updated:\n                break\n        return dist\n\n    # Dijkstra's algorithm with a priority queue using a counter for tie-breaking\n    heap = []\n    counter = 0\n    heapq.heappush(heap, (0.0, counter, start))\n    counter += 1\n\n    while heap:\n        d_u, _, u = heapq.heappop(heap)\n        # Skip if this entry is stale\n        if d_u != dist[u]:\n            continue\n        # Explore neighbors; nodes without outgoing edges default to empty dict\n        for v, w in adj.get(u, {}).items():\n            # Relaxation step\n            new_dist = d_u + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(heap, (new_dist, counter, v))\n                counter += 1\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395790.401665,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen1_child1_2": {
        "id": "generic_shortest_path_problem_gen1_child1_2",
        "code": "from heapq import heappush, heappop\n\ndef solve_shortest_paths(data):\n    # Support input as (graph, start) tuple/list or {'graph': ..., 'start': ...} dict\n    if isinstance(data, dict):\n        if 'graph' not in data or 'start' not in data:\n            return None\n        graph, start = data.get('graph'), data.get('start')\n    elif isinstance(data, (list, tuple)) and len(data) == 2:\n        graph, start = data\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes (including those that appear only as neighbors)\n    nodes = set(graph.keys())\n    negative_edge_present = False\n    for u, neighbors in graph.items():\n        if not isinstance(neighbors, dict):\n            return None\n        for v, w in neighbors.items():\n            nodes.add(v)\n            # Validate weight types up front\n            if not isinstance(w, (int, float)):\n                return None\n            if w < 0:\n                negative_edge_present = True\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    if negative_edge_present:\n        # Bellman-Ford for graphs with negative weights (assumes no negative cycles)\n        n = len(nodes)\n        for _ in range(n - 1):\n            updated = False\n            for u in nodes:\n                du = dist[u]\n                if du == float('inf'):\n                    continue\n                for v, w in graph.get(u, {}).items():\n                    nd = du + w\n                    if nd < dist[v]:\n                        dist[v] = nd\n                        updated = True\n            if not updated:\n                break\n        return dist\n    else:\n        # Dijkstra's algorithm using a min-heap for non-negative weights\n        heap = [(0.0, start)]\n        while heap:\n            cur_dist, u = heappop(heap)\n            if cur_dist > dist[u]:\n                continue\n            # Iterate over neighbors; nodes that are not in graph have no outgoing edges\n            for v, w in graph.get(u, {}).items():\n                nd = cur_dist + w\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heappush(heap, (nd, v))\n        return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1762889025.7690225,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen2_child0_0": {
        "id": "generic_shortest_path_problem_gen2_child0_0",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # CAUSAL: Support both call styles to avoid signature mismatch:\n    # - solve_shortest_paths(graph, start[, cfg])\n    # - solve_shortest_paths([graph, start[, cfg]])\n    if len(args) == 0:\n        return {}\n    if len(args) == 1 and isinstance(args[0], (list, tuple)):\n        in_args = args[0]\n        input_shape = \"single-sequence\"\n    else:\n        in_args = args\n        input_shape = \"varargs\"\n\n    # Parse inputs\n    if not isinstance(in_args, (list, tuple)) or len(in_args) < 2:\n        return {}\n    graph = in_args[0] if isinstance(in_args[0], dict) else {}\n    start = in_args[1]\n\n    # Optional configuration\n    cfg = {}\n    if len(in_args) >= 3 and isinstance(in_args[2], dict):\n        cfg = in_args[2]\n    max_relaxations = cfg.get(\"max_relaxations\", None)\n    max_pops = cfg.get(\"max_pops\", None)\n    # No-op logger by default\n    log_fn = cfg.get(\"log_fn\", None)\n    def log(*_a, **_k):\n        if callable(log_fn):\n            try:\n                log_fn(*_a, **_k)\n            except Exception:\n                pass\n    # Targeted debug to help reproduce input parsing issues\n    log(\"solve_shortest_paths input normalization:\", input_shape)\n\n    # Collect all nodes (including implicit ones and the start)\n    nodes = set(graph.keys())\n    for u in graph:\n        neighbors = graph.get(u, {})\n        if isinstance(neighbors, dict):\n            nodes.update(neighbors.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0.0, start)]\n    relaxations = 0\n    pops = 0\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        pops += 1\n        if max_pops is not None and pops > max_pops:\n            break\n        # Skip if this entry is stale\n        if d != dist[u]:\n            continue\n        # Traverse neighbors\n        for v, w in graph.get(u, {}).items():\n            try:\n                weight = float(w)\n            except Exception:\n                # If weight is not a number, skip this edge\n                continue\n            nd = d + weight\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n                relaxations += 1\n                if max_relaxations is not None and relaxations > max_relaxations:\n                    log(\"Relaxation budget exceeded; returning partial results.\")\n                    heap = []\n                    break\n\n    return dist",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.54726159820954,
            "passed_tests": 11.0,
            "total_tests": 11.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog5",
        "island_id": 2,
        "errors": [],
        "status": "evaluated",
        "created_at": 1763395991.9142687,
        "task_id": "generic_shortest_path_problem",
        "fitness": 1.0,
        "metrics": {
            "correctness": 1.0,
            "runtime_ms": 0.54726159820954,
            "passed_tests": 11.0,
            "total_tests": 11.0,
            "highest_level_passed": 0.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen2_child0_2": {
        "id": "generic_shortest_path_problem_gen2_child0_2",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set()\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        nodes.add(u)\n        for v in nbrs.keys():\n            nodes.add(v)\n    nodes.add(start)\n\n    adj = {node: {} for node in nodes}\n    for u, nbrs in graph.items():\n        for v, w in nbrs.items():\n            adj[u][v] = w\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n    pq = [(0.0, start)]\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u].items():\n            try:\n                nd = d + w\n            except TypeError:\n                return None\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n        result = {}\n    for node in nodes:\n        d = dist.get(node, float('inf'))\n        result[node] = d\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1762889107.0490036,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen2_child1_0": {
        "id": "generic_shortest_path_problem_gen2_child1_0",
        "code": "def solve_shortest_paths(args):\n    \"\"\"\n    Key constraints and safeguards:\n    - Search loops: Use Dijkstra's algorithm with a priority queue and stale-entry skipping to ensure termination.\n    - Random seed management: No randomness is used; algorithm is fully deterministic.\n    - Telemetry capture: Not required; minimal internal counters only if needed (not returned).\n    - Reproducibility safeguards: Pure function behavior; no side effects, deterministic ordering via heapq.\n    \"\"\"\n    import heapq\n\n        # Parse inputs\n    graph = {}\n    start = None\n    if isinstance(args, (list, tuple)) and len(args) == 2:\n        graph, start = args\n    elif isinstance(args, dict):\n        # Treat args as the graph when a dict is provided directly\n        graph = args\n        start = next(iter(graph), None)\n    else:\n        # Attempt to unpack non-dict iterables of length 2; otherwise, default to empty graph and no start\n        try:\n            if hasattr(args, '__iter__') and not isinstance(args, dict):\n                temp = list(args)\n                if len(temp) == 2:\n                    graph, start = temp\n                else:\n                    graph = {}\n                    start = None\n            else:\n                graph = {}\n                start = None\n        except Exception:\n            graph = {}\n            start = None\n\n    if graph is None:\n        graph = {}\n    # Ensure start exists; if still None (no nodes at all), define a placeholder None as start\n    # but to keep hashability, we allow None as a key.\n    # The examples assume a concrete start; if not provided, we still return {start: 0}.\n    # This aligns with the pattern: when graph is empty, return {start: 0}.\n    # If start is not provided at all, we keep None.\n    # Build the full node set including implicit nodes and the start.\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u in graph:\n            nbrs = graph.get(u, {})\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    if start is not None:\n        nodes.add(start)\n\n        # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    if start is None:\n        # No start provided and graph had no nodes: define start as None and return {None: 0}\n        # But ensure consistent behavior per examples: if graph is empty and start given, return {start:0}\n        # Here start is None; set distance for None.\n        dist = {None: 0}\n        return dist\n\n        dist[start] = 0\n\n    # Priority queue: (distance, tie-breaker, node)\n    counter = 0\n    heap = [(0, counter, start)]\n    # Dijkstra's algorithm\n    while heap:\n        d_u, _, u = heapq.heappop(heap)\n        # Skip stale entries\n        if d_u != dist.get(u, float('inf')):\n            continue\n        # Explore neighbors; handle nodes possibly missing in graph by using empty dict\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            # Assume non-negative weights as per typical Dijkstra prerequisites.\n            try:\n                nd = d_u + w\n            except TypeError:\n                # Fallback: attempt float conversion for non-numeric weight types\n                try:\n                    nd = d_u + float(w)\n                except Exception:\n                    # Skip invalid edge weights that cannot be interpreted numerically\n                    continue\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                counter += 1\n                heapq.heappush(heap, (nd, counter, v))\n\n    # Ensure all nodes encountered implicitly are present in the output\n    for node in nodes:\n        if node not in dist:\n            dist[node] = float('inf')\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog4",
        "island_id": 4,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763396115.8609865,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen2_child1_1": {
        "id": "generic_shortest_path_problem_gen2_child1_1",
        "code": "def solve_shortest_paths(args):\n    \"\"\"\n    Key constraints and safeguards:\n    - Search loops: Use Dijkstra's algorithm with a priority queue and stale-entry skipping to ensure termination.\n    - Random seed management: No randomness is used; algorithm is fully deterministic.\n    - Telemetry capture: Not required; minimal internal counters only if needed (not returned).\n    - Reproducibility safeguards: Pure function behavior; no side effects, deterministic ordering via heapq.\n    \"\"\"\n    import heapq\n\n    # Parse inputs\n    graph = {}\n    start = None\n    if isinstance(args, (list, tuple)) and len(args) == 2:\n        graph, start = args\n    else:\n        # Fallback: try to interpret args as (graph, start)\n        try:\n            graph, start = args  # Unpack if args is an iterable of length 2\n        except Exception:\n            # As last resort, treat args as graph with missing start (undefined behavior),\n            # but to adhere to spec we set start to a default unique object; return only that if empty.\n            graph = args if isinstance(args, dict) else {}\n            start = next(iter(graph), None)\n\n    if graph is None:\n        graph = {}\n    # Ensure start exists; if still None (no nodes at all), define a placeholder None as start\n    # but to keep hashability, we allow None as a key.\n    # The examples assume a concrete start; if not provided, we still return {start: 0}.\n    # This aligns with the pattern: when graph is empty, return {start: 0}.\n    # If start is not provided at all, we keep None.\n    # Build the full node set including implicit nodes and the start.\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u in graph:\n            nbrs = graph.get(u, {})\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    if start is not None:\n        nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n        if start is None:\n        # No start provided and graph had no nodes: define start as None and return {None: 0}\n        # But ensure consistent behavior per examples: if graph is empty and start given, return {start:0}\n        # Here start is None; set distance for None.\n        # Preserve integer semantics for zero distance to match expected types.\n        dist = {None: 0}\n        return dist\n\n        # Preserve integer semantics for zero distance when weights are integers.\n    dist[start] = 0\n\n    # Priority queue: (distance, node)\n    heap = [(dist[start], start)]\n    # Dijkstra's algorithm\n    while heap:\n        d_u, u = heapq.heappop(heap)\n        # Skip stale entries\n        if d_u != dist.get(u, float('inf')):\n            continue\n        # Explore neighbors; handle nodes possibly missing in graph by using empty dict\n                for v, w in graph.get(u, {}).items():\n            # Assume non-negative weights as per typical Dijkstra prerequisites.\n            # Keep weight types as provided to preserve integer distances when possible.\n            assert isinstance(w, (int, float)), f\"Non-numeric edge weight on {u}->{v}: {w!r}\"\n            nd = d_u + w\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Ensure all nodes encountered implicitly are present in the output\n    for node in nodes:\n        if node not in dist:\n            dist[node] = float('inf')\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog4",
        "island_id": 4,
        "errors": [
            "SyntaxError: unexpected indent at line 46, offset 8"
        ],
        "status": "failed_evaluation",
        "created_at": 1763396001.0582917,
        "task_id": "generic_shortest_path_problem",
        "fitness": null,
        "metrics": {},
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen2_child1_2": {
        "id": "generic_shortest_path_problem_gen2_child1_2",
        "code": "from heapq import heappush, heappop\n\ndef solve_shortest_paths(data):\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n    if not isinstance(graph, dict):\n        return None\n\n        # Collect all nodes (including those that appear only as neighbors) and validate edges\n    nodes = set(graph.keys())\n    edges = []\n    for u, neighbors in graph.items():\n        if not isinstance(neighbors, dict):\n            return None\n        for v, w in neighbors.items():\n            nodes.add(v)\n            if not isinstance(w, (int, float)):\n                return None\n            edges.append((u, v, float(w)))\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # If there are negative weights, use Bellman-Ford; otherwise use Dijkstra\n    has_negative = any(w < 0 for _, _, w in edges)\n    if has_negative:\n        n = len(nodes)\n        for _ in range(n - 1):\n            updated = False\n            for u, v, w in edges:\n                if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    updated = True\n            if not updated:\n                break\n        # Detect negative cycles reachable from start\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                return None\n        return dist\n    else:\n        # Dijkstra's algorithm using a min-heap\n        heap = [(0.0, start)]\n        # Build adjacency from validated edges\n        adj = {}\n        for node in nodes:\n            adj[node] = {}\n        for u, v, w in edges:\n            adj[u][v] = w\n        while heap:\n            cur_dist, u = heappop(heap)\n            if cur_dist > dist[u]:\n                continue\n            # Iterate over neighbors; nodes that are not in graph have no outgoing edges\n            for v, w in adj.get(u, {}).items():\n                nd = cur_dist + w\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heappush(heap, (nd, v))\n        return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1762889103.9303493,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen2_child0_1": {
        "id": "generic_shortest_path_problem_gen2_child0_1",
        "code": "def solve_shortest_paths(args):\n    import heapq\n\n    # Parse inputs\n    if not isinstance(args, (list, tuple)) or len(args) < 2:\n        return {}\n    graph = args[0] if isinstance(args[0], dict) else {}\n    start = args[1]\n\n    # Optional configuration\n    cfg = {}\n    if len(args) >= 3 and isinstance(args[2], dict):\n        cfg = args[2]\n    max_relaxations = cfg.get(\"max_relaxations\", None)\n    max_pops = cfg.get(\"max_pops\", None)\n    # No-op logger by default\n    log_fn = cfg.get(\"log_fn\", None)\n    def log(*_a, **_k):\n        if callable(log_fn):\n            try:\n                log_fn(*_a, **_k)\n            except Exception:\n                pass\n\n    # Collect all nodes (including implicit ones and the start)\n    nodes = set(graph.keys())\n    for u in graph:\n        neighbors = graph.get(u, {})\n        if isinstance(neighbors, dict):\n            nodes.update(neighbors.keys())\n    nodes.add(start)\n\n        # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Build edge list and detect negative weights (causal path: Dijkstra fails on negative weights)\n    edges = []\n    has_negative = False\n    for u in graph:\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            continue\n        for v, w in neighbors.items():\n            try:\n                weight = float(w)\n            except Exception:\n                # Targeted log to help reproduce invalid input issues\n                log(\"Skipping non-numeric weight\", {\"edge\": (u, v), \"weight\": w})\n                continue\n            if weight < 0:\n                has_negative = True\n            edges.append((u, v, weight))\n\n    relaxations = 0\n    pops = 0\n\n    if has_negative:\n        # Switch to Bellman-Ford when negative edges exist (causal path mitigation)\n        log(\"Negative edge detected; using Bellman-Ford.\")\n        n = len(nodes)\n        for i in range(n - 1):\n            changed = False\n            for u, v, w in edges:\n                if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    relaxations += 1\n                    changed = True\n                    if max_relaxations is not None and relaxations > max_relaxations:\n                        log(\"Relaxation budget exceeded during Bellman-Ford; returning partial results.\")\n                        return dist\n            if not changed:\n                break\n    else:\n        # Dijkstra's algorithm using a min-heap\n        heap = [(0.0, start)]\n        while heap:\n            d, u = heapq.heappop(heap)\n            pops += 1\n            if max_pops is not None and pops > max_pops:\n                break\n            # Skip if this entry is stale\n            if d > dist[u]:\n                continue\n            # Traverse neighbors\n            for v, w in graph.get(u, {}).items():\n                try:\n                    weight = float(w)\n                except Exception:\n                    # If weight is not a number, skip this edge\n                    log(\"Skipping non-numeric weight\", {\"edge\": (u, v), \"weight\": w})\n                    continue\n                nd = d + weight\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heapq.heappush(heap, (nd, v))\n                    relaxations += 1\n                    if max_relaxations is not None and relaxations > max_relaxations:\n                        log(\"Relaxation budget exceeded; returning partial results.\")\n                        heap = []\n                        break\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog5",
        "island_id": 2,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763396056.4332232,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "erdos_993_alphaevolve_counterexample_v1_gen0_prog0": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog0",
        "code": "def propose_forest_candidate(n: int):\n    edges = []\n\n    def add_double_star(start, total_nodes):\n        # total_nodes = 2 hubs + a + b leaves\n        h1 = start\n        h2 = start + 1\n        if total_nodes >= 2:\n            edges.append((h1, h2))\n        leaves = total_nodes - 2\n        a = leaves // 2\n        b = leaves - a\n        nextv = start + 2\n        for _ in range(a):\n            edges.append((h1, nextv))\n            nextv += 1\n        for _ in range(b):\n            edges.append((h2, nextv))\n            nextv += 1\n        return nextv\n\n    def add_comet(start, total_nodes):\n        # total_nodes = 1 hub + chain_len + k leaves\n        if total_nodes <= 0:\n            return start\n        hub = start\n        nextv = start + 1\n        if total_nodes == 1:\n            return start + 1\n        rem = total_nodes - 1\n        chain_len = max(1, rem // 2)\n        if chain_len > rem:\n            chain_len = rem\n        k = rem - chain_len\n        prev = hub\n        for _ in range(chain_len):\n            v = nextv\n            nextv += 1\n            edges.append((prev, v))\n            prev = v\n        for _ in range(k):\n            v = nextv\n            nextv += 1\n            edges.append((hub, v))\n        return nextv\n\n    def add_star(start, leaves):\n        # 1 center + leaves leaves\n        center = start\n        for i in range(1, leaves + 1):\n            edges.append((center, start + i))\n        return start + 1 + leaves\n\n    def add_path(start, m):\n        if m <= 1:\n            return start + m\n        prev = start\n        for i in range(1, m):\n            v = start + i\n            edges.append((prev, v))\n            prev = v\n        return start + m\n\n    if n <= 1:\n        return edges\n    if n <= 5:\n        # simple path uses all vertices\n        add_path(0, n)\n        return edges\n\n    # Allocate nodes to components: double-star, comet, and leftover mini-stars\n    d = max(2, int(n * 0.45))\n    if d > n:\n        d = n\n    rem = n - d\n    if rem <= 0:\n        add_double_star(0, d)\n        return edges\n\n    c = min(max(1, int(n * 0.35)), rem)\n    p = n - d - c\n\n    cur = 0\n    # Double-star component\n    cur = add_double_star(cur, d)\n\n    # Comet component\n    if c > 0:\n        cur = add_comet(cur, c)\n\n    # Use leftover nodes to build several mini-stars (alternating sizes) or small paths\n    remaining = p\n    star_index = 0\n    while remaining >= 4:\n        t = 3 if (star_index % 2 == 0) else 2\n        group = t + 1\n        if group > remaining:\n            t = remaining - 1\n            group = remaining\n        cur = add_star(cur, t)\n        remaining -= group\n        star_index += 1\n\n    if remaining == 3:\n        cur = add_star(cur, 2)\n        remaining -= 3\n    elif remaining == 2:\n        cur = add_path(cur, 2)\n        remaining -= 2\n    elif remaining == 1:\n        # single isolated vertex, no edges\n        cur += 1\n        remaining -= 1\n\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.00391155481338501,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889511.1984131,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen0_prog1": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog1",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    adjacency = [set() for _ in range(n)]\n\n    def add_edge(u, v):\n        if u == v:\n            return\n        if 0 <= u < n and 0 <= v < n:\n            adjacency[u].add(v)\n            adjacency[v].add(u)\n\n    def add_double_star(start, a, b):\n        u = start\n        v = start + 1\n        add_edge(u, v)\n        # Leaves for u\n        for i in range(a):\n            leaf = start + 2 + i\n            add_edge(u, leaf)\n        # Leaves for v\n        for j in range(b):\n            leaf = start + 2 + a + j\n            add_edge(v, leaf)\n\n    remaining = n\n    idx = 0\n    pair_index = 0\n    ds_pairs = [(2, 3), (2, 4), (3, 3), (3, 4), (4, 4), (3, 5), (5, 3), (4, 5)]\n\n    while remaining >= 7:\n        candidate_pairs = []\n        for p in ds_pairs:\n            size = p[0] + p[1] + 2\n            if size <= remaining:\n                candidate_pairs.append(p)\n        if not candidate_pairs:\n            break\n        p = candidate_pairs[pair_index % len(candidate_pairs)]\n        a, b = p\n        add_double_star(idx, a, b)\n        size = a + b + 2\n        idx += size\n        remaining -= size\n        pair_index += 1\n\n    if remaining == 0:\n        pass\n    elif remaining == 1:\n        # Isolated vertex at idx\n        idx += 1\n        remaining -= 1\n    elif remaining == 2:\n        add_edge(idx, idx + 1)\n        idx += 2\n        remaining -= 2\n    elif remaining == 3:\n        add_edge(idx, idx + 1)\n        add_edge(idx + 1, idx + 2)\n        idx += 3\n        remaining -= 3\n    else:\n        # Star consumes the remaining vertices\n        center = idx\n        for leaf in range(idx + 1, idx + remaining):\n            add_edge(center, leaf)\n        idx += remaining\n        remaining = 0\n\n    return [sorted(list(neigh)) for neigh in adjacency]",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.006918236613273621,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889511.19931,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen0_prog2": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    adj = [[] for _ in range(n)]\n    u = 0\n    idx = 0\n    while u < n:\n        r = n - u\n        if r == 1:\n            # single isolated vertex component\n            u += 1\n            idx += 1\n            continue\n        if r <= 5:\n            # use a star with center and r-1 leaves\n            center = u\n            for v in range(u + 1, u + r):\n                adj[center].append(v)\n                adj[v].append(center)\n            u += r\n            idx += 1\n            continue\n        # r >= 6: build a broom component (star + path from center)\n        s = 3 + ((idx * 2 + n) % 4)  # number of star leaves: 3..6\n        p = 2 + ((idx + n) % 3)      # path length from center: 2..4\n        total = 1 + s + p            # center + leaves + path vertices\n        if total > r:\n            extra = total - r\n            reduce_s = min(extra, max(0, s - 1))\n            s -= reduce_s\n            extra -= reduce_s\n            if extra > 0:\n                reduce_p = min(extra, max(0, p - 1))\n                p -= reduce_p\n                extra -= reduce_p\n            total = 1 + s + p\n            if total > r or s < 1 or p < 1:\n                # fallback to a simple path on r vertices\n                for i in range(u, u + r - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n                u += r\n                idx += 1\n                continue\n        center = u\n        # connect star leaves\n        for v in range(u + 1, u + 1 + s):\n            adj[center].append(v)\n            adj[v].append(center)\n        # attach a path starting from center\n        if p > 0:\n            first_chain = u + 1 + s\n            adj[center].append(first_chain)\n            adj[first_chain].append(center)\n            for i in range(first_chain, first_chain + p - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n        u += total\n        idx += 1\n    return adj",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.002973899245262146,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889511.2000682,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen0_prog3": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    if n == 1:\n        return []\n    # Determine spine size (path component)\n    spine_count = min(n, max(2, n // 3))\n    edges = []\n    # Build path (spine)\n    for i in range(spine_count - 1):\n        edges.append((i, i + 1))\n    next_label = spine_count\n    # Attach one leaf to each spine vertex as available\n    for i in range(spine_count):\n        if next_label >= n:\n            break\n        edges.append((i, next_label))\n        next_label += 1\n    # Create a star component and connect its center to the end of the spine\n    if next_label < n:\n        star_center = next_label\n        next_label += 1\n        # Connect star center to the last spine vertex to keep the whole graph a single tree\n        edges.append((star_center, spine_count - 1))\n        # Attach remaining vertices as leaves of the star center\n        while next_label < n:\n            edges.append((star_center, next_label))\n            next_label += 1\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.0018887221813201904,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889511.200699,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen0_prog4": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog4",
        "code": "def propose_forest_candidate(n: int):\n    import math\n\n    edges = []\n\n    def add_edge(u, v):\n        if u == v:\n            return\n        if u > v:\n            u, v = v, u\n        edges.append((u, v))\n\n    def build_path(offset, size):\n        if size <= 1:\n            return\n        for i in range(offset, offset + size - 1):\n            add_edge(i, i + 1)\n\n    def build_spider(offset, size, r_hint):\n        S = size\n        if S <= 0:\n            return\n        if S == 1:\n            return\n        if S == 2:\n            build_path(offset, 2)\n            return\n        r = max(1, min(S - 1, r_hint))\n        center = offset\n        for i in range(r):\n            leg = offset + 1 + i\n            add_edge(center, leg)\n        leaves_count = S - (1 + r)\n        if leaves_count > 0 and r > 0:\n            sumW = r * (r + 1) // 2\n            Li = []\n            assigned = 0\n            for i in range(r):\n                w = i + 1\n                xi = (leaves_count * w) // sumW\n                Li.append(xi)\n                assigned += xi\n            rem = leaves_count - assigned\n            i = 0\n            while rem > 0 and i < r:\n                Li[i] += 1\n                rem -= 1\n                i += 1\n            leaf_id = offset + 1 + r\n            for i in range(r):\n                leg = offset + 1 + i\n                for _ in range(Li[i]):\n                    add_edge(leg, leaf_id)\n                    leaf_id += 1\n\n    if n <= 0:\n        return []\n    if n <= 3:\n        build_path(0, n)\n        return edges\n\n    sizeA = max(3, n // 2)\n    sizeB = n - sizeA\n\n    rA = min(sizeA - 1, max(2, int(math.sqrt(sizeA))))\n    rB = min(sizeB - 1, max(2, int(math.log(sizeB + 2))))\n\n    pos = 0\n    build_spider(pos, sizeA, rA)\n    pos += sizeA\n\n    if sizeB >= 3:\n        build_spider(pos, sizeB, rB)\n    elif sizeB == 2:\n        build_path(pos, 2)\n    # if sizeB == 1, leave as isolated vertex\n\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.007615052163600922,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889511.2014043,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen1_child0_0": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen1_child0_0",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    if n == 1:\n        return []\n    edges = []\n    # Build a \"double-broom\" backbone path to encourage lumpy independent-set counts\n    # Choose path vertex count p deterministically from n\n    p = max(2, min(n, n // 4 + 2))\n    # Path on vertices 0..p-1\n    for i in range(p - 1):\n        edges.append((i, i + 1))\n    next_label = p\n    rem = n - p\n    if rem <= 0:\n        return edges\n    # Allocate some vertices to separate star components\n    extra_comp = rem // 5\n    # Leaves to attach to both ends of the path\n    leaves_left = rem - extra_comp\n    la = leaves_left // 2\n    lb = leaves_left - la\n    # Attach leaves to node 0\n    for _ in range(la):\n        if next_label >= n:\n            break\n        edges.append((0, next_label))\n        next_label += 1\n    # Attach leaves to node p-1\n    for _ in range(lb):\n        if next_label >= n:\n            break\n        edges.append((p - 1, next_label))\n        next_label += 1\n    # Build extra small star components using remaining vertices\n    # Alternate leaf counts (1,2,3) for variety while keeping acyclicity\n    pattern = [1, 2, 3]\n    pat_idx = 0\n    while next_label < n:\n        center = next_label\n        next_label += 1\n        # If no vertices remain after choosing a center, it becomes isolated (valid in a forest)\n        if next_label >= n:\n            break\n        leaf_count = pattern[pat_idx % len(pattern)]\n        pat_idx += 1\n        actual_leaves = min(leaf_count, n - next_label)\n        for _ in range(actual_leaves):\n            edges.append((center, next_label))\n            next_label += 1\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.00233333557844162,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 1,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889652.9695215,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen1_child0_1": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen1_child0_1",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    if n == 1:\n        return []\n    edges = []\n    # Choose a spine length that varies deterministically with n\n    spine_len = max(2, min(n, (n // 3) + (1 if n % 3 == 0 else 0)))\n    if spine_len > n:\n        spine_len = n\n    # Build the spine using vertices 0..spine_len-1\n    for i in range(spine_len - 1):\n        edges.append((i, i + 1))\n    next_label = spine_len\n    # First pass: attach one leaf to each internal spine vertex (if available)\n    for i in range(1, spine_len - 1):\n        if next_label >= n:\n            break\n        edges.append((i, next_label))\n        next_label += 1\n    # Second pass: attach an extra leaf to every other internal spine vertex (if available)\n    for i in range(1, spine_len - 1, 2):\n        if next_label >= n:\n            break\n        edges.append((i, next_label))\n        next_label += 1\n    # Create up to two hub centers attached to the ends of the spine\n    hub1 = None\n    hub2 = None\n    if next_label < n:\n        hub1 = next_label\n        next_label += 1\n        edges.append((hub1, 0))\n    if next_label < n:\n        hub2 = next_label\n        next_label += 1\n        edges.append((hub2, spine_len - 1))\n    # Distribute remaining vertices as leaves alternately to hub1 and hub2 (if available),\n    # otherwise attach them to the spine endpoints to keep the graph a tree.\n    attach_toggle = 0\n    while next_label < n:\n        if hub1 is not None and hub2 is not None:\n            target = hub1 if attach_toggle % 2 == 0 else hub2\n            attach_toggle += 1\n        elif hub1 is not None:\n            target = hub1\n        elif hub2 is not None:\n            target = hub2\n        else:\n            target = 0 if attach_toggle % 2 == 0 else spine_len - 1\n            attach_toggle += 1\n        edges.append((target, next_label))\n        next_label += 1\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.002543441951274872,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 1,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889637.0617664,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen1_child0_2": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen1_child0_2",
        "code": "def propose_forest_candidate(n: int):\n    # Deterministic construction of a forest combining a large star, a path, and optionally a small star.\n    edges = []\n    if n <= 0:\n        return edges\n    # Choose component sizes: large star ~ 2n/3, path ~ half of remainder, small star gets the rest.\n    a = min(n, max(2, (2 * n) // 3))  # size of large star component (number of vertices)\n    remain = n - a\n    b = 0\n    if remain >= 2:\n        b = min(remain, max(2, remain // 2))  # size of path component (number of vertices)\n    c = n - a - b  # size of small star component (may be 0 or 1 -> isolated vertices)\n    # Build large star on labels 0..a-1\n    if a >= 2:\n        center = 0\n        for leaf in range(1, a):\n            edges.append((center, leaf))\n    # Build path on labels a..a+b-1\n    if b >= 2:\n        base = a\n        for i in range(base, base + b - 1):\n            edges.append((i, i + 1))\n    # Build small star on labels a+b..n-1\n    if c >= 2:\n        center2 = a + b\n        for leaf in range(center2 + 1, n):\n            edges.append((center2, leaf))\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.0020192936062812805,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 1,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889717.0761063,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen1_child1_0": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen1_child1_0",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    adj = [[] for _ in range(n)]\n    u = 0\n    idx = 0\n    while u < n:\n        r = n - u\n        if r == 1:\n            # single isolated vertex component\n            u += 1\n            idx += 1\n            continue\n        if r <= 5:\n            # alternate small component between path and star, deterministically\n            if ((idx + n) % 2) == 0:\n                # simple path on r vertices\n                for i in range(u, u + r - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n            else:\n                # star with center u and r-1 leaves\n                center = u\n                for v in range(u + 1, u + r):\n                    adj[center].append(v)\n                    adj[v].append(center)\n            u += r\n            idx += 1\n            continue\n        # Larger components: prefer \"double broom\" (two paths from a center plus leaves)\n        if r >= 8:\n            s = 3 + ((idx * 3 + n) % 5)  # leaves: 3..7\n            p1 = 2 + ((idx + n) % 4)     # first path length: 2..5\n            p2 = 2 + ((idx * 2 + n) % 4) # second path length: 2..5\n            total = 1 + s + p1 + p2\n            if total > r:\n                extra = total - r\n                # reduce leaves first, but keep at least 1\n                reduce_s = min(extra, max(0, s - 1))\n                s -= reduce_s\n                extra -= reduce_s\n                if extra > 0:\n                    # reduce the longer of the two paths first, keeping at least 1\n                    if p1 >= p2:\n                        reduce_p1 = min(extra, max(0, p1 - 1))\n                        p1 -= reduce_p1\n                        extra -= reduce_p1\n                    if extra > 0:\n                        reduce_p2 = min(extra, max(0, p2 - 1))\n                        p2 -= reduce_p2\n                        extra -= reduce_p2\n                total = 1 + s + p1 + p2\n            if total <= r and s >= 1 and p1 >= 1 and p2 >= 1:\n                center = u\n                # connect leaves\n                for v in range(u + 1, u + 1 + s):\n                    adj[center].append(v)\n                    adj[v].append(center)\n                # first path from center\n                t1 = u + 1 + s\n                adj[center].append(t1)\n                adj[t1].append(center)\n                for i in range(t1, t1 + p1 - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n                # second path from center\n                t2 = t1 + p1\n                adj[center].append(t2)\n                adj[t2].append(center)\n                for i in range(t2, t2 + p2 - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n                u += total\n                idx += 1\n                continue\n            # if fitting failed, fallback to a single broom below\n        # r >= 6: build a broom component (star + path from center)\n        s = 3 + ((idx * 2 + n) % 4)  # number of star leaves: 3..6\n        p = 2 + ((idx + n) % 3)      # path length from center: 2..4\n        total = 1 + s + p            # center + leaves + path vertices\n        if total > r:\n            extra = total - r\n            reduce_s = min(extra, max(0, s - 1))\n            s -= reduce_s\n            extra -= reduce_s\n            if extra > 0:\n                reduce_p = min(extra, max(0, p - 1))\n                p -= reduce_p\n                extra -= reduce_p\n            total = 1 + s + p\n            if total > r or s < 1 or p < 1:\n                # fallback to a simple path on r vertices\n                for i in range(u, u + r - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n                u += r\n                idx += 1\n                continue\n        center = u\n        # connect star leaves\n        for v in range(u + 1, u + 1 + s):\n            adj[center].append(v)\n            adj[v].append(center)\n        # attach a path starting from center\n        if p > 0:\n            first_chain = u + 1 + s\n            adj[center].append(first_chain)\n            adj[first_chain].append(center)\n            for i in range(first_chain, first_chain + p - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n        u += total\n        idx += 1\n    return adj",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.003443285822868347,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 1,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "island_id": 2,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889691.1380236,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen1_child1_1": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen1_child1_1",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    edges = []\n    u = 0\n    idx = 0\n\n    def add_edge(a: int, b: int):\n        if a == b:\n            return\n        if a > b:\n            a, b = b, a\n        edges.append((a, b))\n\n    while u < n:\n        r = n - u\n        if r == 1:\n            # isolated vertex\n            u += 1\n            idx += 1\n            continue\n\n        # Small components: simple path for robustness and determinism\n        if r <= 4:\n            for i in range(u, u + r - 1):\n                add_edge(i, i + 1)\n            u += r\n            idx += 1\n            continue\n\n        # Medium components (5..6): double-star (two centers connected)\n        if r <= 6:\n            c1 = u\n            c2 = u + 1\n            add_edge(c1, c2)\n            remaining = r - 2\n            s1 = 1 + ((idx + n) % 2)           # 1..2 leaves on c1\n            s2 = 1 + ((idx * 2 + n) % 2)       # 1..2 leaves on c2\n            # Adjust leaves if exceeding remaining vertices\n            if s1 + s2 > remaining:\n                total_leaves = remaining\n                s1 = min(s1, total_leaves)\n                total_leaves -= s1\n                s2 = min(s2, total_leaves)\n            # Attach leaves\n            next_v = u + 2\n            for _ in range(s1):\n                add_edge(c1, next_v)\n                next_v += 1\n            for _ in range(s2):\n                add_edge(c2, next_v)\n                next_v += 1\n            u += (next_v - u)\n            idx += 1\n            continue\n\n        # Large components (r >= 7): bi-broom (two centers with leaves and short chains)\n        c1 = u\n        c2 = u + 1\n        add_edge(c1, c2)\n\n        s1 = 2 + ((idx + n) % 3)              # 2..4 leaves on c1\n        s2 = 2 + ((idx * 2 + n) % 3)          # 2..4 leaves on c2\n        p = 1 + ((idx + n) % 2)               # 1..2 chain from c1\n        q = ((idx * 3 + n) % 2)               # 0..1 chain from c2\n\n        total = 2 + s1 + s2 + p + q\n        if total > r:\n            extra = total - r\n            # reduce q, then p (keeping p >= 1), then s2, then s1 (keeping >= 1)\n            dq = min(extra, q)\n            q -= dq\n            extra -= dq\n            dp = min(extra, max(0, p - 1))\n            p -= dp\n            extra -= dp\n            ds2 = min(extra, max(0, s2 - 1))\n            s2 -= ds2\n            extra -= ds2\n            ds1 = min(extra, max(0, s1 - 1))\n            s1 -= ds1\n            extra -= ds1\n            total = 2 + s1 + s2 + p + q\n\n        # If parameters collapse, fallback to caterpillar or path\n        if s1 < 1 or s2 < 1 or p < 1 or total > r:\n            # Attempt a small caterpillar backbone if possible\n            b = min(r, 5 + ((idx + n) % 3))   # backbone size\n            if b < 3 or b > r:\n                # fallback to path on r vertices\n                for i in range(u, u + r - 1):\n                    add_edge(i, i + 1)\n                u += r\n                idx += 1\n                continue\n            # backbone path\n            for i in range(u, u + b - 1):\n                add_edge(i, i + 1)\n            used = b\n            internal = max(0, b - 2)\n            leaves_per = 1 + ((idx * 3 + n) % 2)  # 1..2 leaves per internal node\n            total_leaves = min(r - used, internal * leaves_per)\n            leaf_ptr = u + b\n            iv = 0\n            while total_leaves > 0 and iv < internal:\n                attach = min(leaves_per, total_leaves)\n                v = u + 1 + iv\n                for _ in range(attach):\n                    add_edge(v, leaf_ptr)\n                    leaf_ptr += 1\n                    total_leaves -= 1\n                iv += 1\n            u += (leaf_ptr - u)\n            idx += 1\n            continue\n\n        # Build the bi-broom component\n        next_v = u + 2\n        # Leaves on c1\n        for _ in range(s1):\n            add_edge(c1, next_v)\n            next_v += 1\n        # Leaves on c2\n        for _ in range(s2):\n            add_edge(c2, next_v)\n            next_v += 1\n        # Chain from c1 of length p\n        prev = c1\n        for _ in range(p):\n            add_edge(prev, next_v)\n            prev = next_v\n            next_v += 1\n        # Chain from c2 of length q\n        prev2 = c2\n        for _ in range(q):\n            add_edge(prev2, next_v)\n            prev2 = next_v\n            next_v += 1\n\n        u += (next_v - u)\n        idx += 1\n\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.003727525472640991,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 1,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "island_id": 2,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889692.7996361,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen1_child1_2": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen1_child1_2",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    edges = []\n    u = 0\n    idx = 0\n    while u < n:\n        r = n - u\n        if r == 1:\n            # single isolated vertex component\n            u += 1\n            idx += 1\n            continue\n        # choose component type deterministically\n        t = (n + idx * 3 + r) % 4\n        if r <= 4:\n            # path on r vertices\n            for i in range(u, u + r - 1):\n                edges.append((i, i + 1))\n            u += r\n            idx += 1\n            continue\n        if t == 0:\n            # star component\n            center = u\n            s = 3 + ((idx + n) % min(5, r - 1))  # number of leaves\n            s = min(s, r - 1)\n            for v in range(u + 1, u + 1 + s):\n                edges.append((center, v))\n            u += 1 + s\n            idx += 1\n            continue\n        if t == 1 and r >= 5:\n            # double-star: two centers connected, leaves distributed\n            c1 = u\n            c2 = u + 1\n            edges.append((c1, c2))\n            m = r - 2  # number of leaves to assign\n            # distribute leaves deterministically\n            s1 = min(1 + ((idx + n) % max(1, m)), m)\n            s2 = m - s1\n            # attach leaves to centers\n            base = u + 2\n            for v in range(base, base + s1):\n                edges.append((c1, v))\n            for v in range(base + s1, base + s1 + s2):\n                edges.append((c2, v))\n            u += 2 + s1 + s2\n            idx += 1\n            continue\n        if t == 2 and r >= 7:\n            # broom: star with leaves and a path from center\n            center = u\n            s = 2 + ((idx * 2 + n) % min(5, r - 3))  # number of star leaves\n            p = 2 + ((idx + n) % 3)  # path length (in vertices) from center\n            total = 1 + s + p\n            if total > r:\n                extra = total - r\n                reduce_s = min(extra, max(0, s - 1))\n                s -= reduce_s\n                extra -= reduce_s\n                if extra > 0:\n                    reduce_p = min(extra, max(0, p - 1))\n                    p -= reduce_p\n                total = 1 + s + p\n            if total > r or s < 1 or p < 1:\n                # fallback to a simple path on r vertices\n                for i in range(u, u + r - 1):\n                    edges.append((i, i + 1))\n                u += r\n                idx += 1\n                continue\n            # connect star leaves\n            for v in range(u + 1, u + 1 + s):\n                edges.append((center, v))\n            # attach a path starting from center\n            first_chain = u + 1 + s\n            edges.append((center, first_chain))\n            for i in range(first_chain, first_chain + p - 1):\n                edges.append((i, i + 1))\n            u += total\n            idx += 1\n            continue\n        # caterpillar component for larger r\n        k = 3 + ((idx + n + r) % 4)  # spine length 3..6\n        k = min(k, max(3, r // 2))\n        m = r - k  # leaves\n        if m <= 0:\n            # fallback to path on r vertices\n            for i in range(u, u + r - 1):\n                edges.append((i, i + 1))\n            u += r\n            idx += 1\n            continue\n        # connect spine\n        for i in range(u, u + k - 1):\n            edges.append((i, i + 1))\n        # distribute leaves among spine nodes\n        pos = u + k\n        total_assigned = 0\n        for j in range(k):\n            remaining = m - total_assigned\n            if remaining <= 0:\n                break\n            base_leaves = 1 + ((idx * 3 + n + j) % 3)  # 1..3 leaves\n            lj = min(base_leaves, remaining)\n            c = u + j\n            for _ in range(lj):\n                edges.append((c, pos))\n                pos += 1\n                total_assigned += 1\n        u += k + total_assigned\n        idx += 1\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.0030415132641792297,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 1,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "island_id": 2,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889716.151785,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen2_child0_0": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen2_child0_0",
        "code": "def propose_forest_candidate(n: int):\n    # Deterministic structured forest aiming for rich independent-set behavior\n    if n <= 0:\n        return []\n    if n == 1:\n        # Single isolated vertex: represented by empty edge list\n        return []\n    if n == 2:\n        # Single edge (simple tree)\n        return [(0, 1)]\n    # Build a \"comb\" component on a spine plus leaves\n    # Spine length chosen to be about a third of n, at least 2\n    spine_count = max(2, n // 3)\n    spine_count = min(spine_count, n)\n    edgeset = set()\n    # Path (spine) on vertices 0..spine_count-1\n    for i in range(spine_count - 1):\n        u, v = i, i + 1\n        a, b = (u, v) if u < v else (v, u)\n        edgeset.add((a, b))\n    next_label = spine_count\n    # Attach one leaf to each spine vertex as available, biased to earlier vertices first\n    for i in range(spine_count):\n        if next_label >= n:\n            break\n        u, v = i, next_label\n        a, b = (u, v) if u < v else (v, u)\n        edgeset.add((a, b))\n        next_label += 1\n    # Create a second component: two connected centers that each host many leaves\n    # If we have at least two vertices left, use them as centers and attach remaining vertices alternatingly\n    if next_label + 1 < n:\n        c1 = next_label\n        c2 = next_label + 1\n        next_label += 2\n        # Connect the two centers\n        a, b = (c1, c2) if c1 < c2 else (c2, c1)\n        edgeset.add((a, b))\n        # Attach remaining vertices as leaves, alternating between c1 and c2 for balance\n        attach_to_c1 = True\n        while next_label < n:\n            target = c1 if attach_to_c1 else c2\n            u, v = target, next_label\n            a, b = (u, v) if u < v else (v, u)\n            edgeset.add((a, b))\n            attach_to_c1 = not attach_to_c1\n            next_label += 1\n    elif next_label < n:\n        # If exactly one vertex remains, leave it isolated (no edges), to keep forest structure diverse\n        # No action needed, as isolated vertices are allowed and represented by the absence of edges\n        pass\n    # Return deterministic list of edges\n    edges = sorted(edgeset)\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.0033112242817878723,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889866.4806654,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen2_child0_1": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen2_child0_1",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    if n == 1:\n        return []\n\n    # Choose a deterministic design based on n to diversify candidate structures.\n    design = n % 4\n    edges = []\n\n    if design == 0:\n        # Double-broom: a short path with many leaves attached to both ends.\n        backbone = max(2, n // 4)\n        for i in range(backbone - 1):\n            edges.append((i, i + 1))\n        next_label = backbone\n        toggle = True\n        while next_label < n:\n            if toggle:\n                edges.append((0, next_label))\n            else:\n                edges.append((backbone - 1, next_label))\n            toggle = not toggle\n            next_label += 1\n\n    elif design == 1:\n        # Caterpillar: backbone path with 1-2 leaves attached per spine vertex in a pattern.\n        spine_count = max(2, n // 3)\n        for i in range(spine_count - 1):\n            edges.append((i, i + 1))\n        next_label = spine_count\n        for i in range(spine_count):\n            # Attach 2 leaves on every 2nd backbone node, else 1 leaf.\n            leaves_here = 2 if (i % 3 == 1) else 1\n            for _ in range(leaves_here):\n                if next_label >= n:\n                    break\n                edges.append((i, next_label))\n                next_label += 1\n            if next_label >= n:\n                break\n\n    elif design == 2:\n        # Star forest: two disjoint star components sharing the remaining vertices.\n        if n >= 2:\n            center1, center2 = 0, 1\n            next_label = 2\n            toggle = True\n            while next_label < n:\n                if toggle:\n                    edges.append((center1, next_label))\n                else:\n                    edges.append((center2, next_label))\n                toggle = not toggle\n                next_label += 1\n        # If n == 1, handled above; if n == 0, handled above.\n\n    else:\n        # Binary tree using heap indexing: parent i connects to children 2*i+1 and 2*i+2.\n        for i in range(n):\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < n:\n                edges.append((i, left))\n            if right < n:\n                edges.append((i, right))\n\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.002054870128631592,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889821.049495,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen2_child0_2": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen2_child0_2",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    if n == 1:\n        return []\n    if n == 2:\n        return [(0, 1)]\n    # Build a \"double broom\" tree: a path backbone with many leaves at both ends\n    # and remaining leaves sprinkled along internal vertices to create asymmetry.\n    # This structure is deterministic and acyclic (a tree).\n    # Determine backbone size\n    path_count = min(n, max(3, n // 4))\n    edges = []\n    # Build path backbone\n    for i in range(path_count - 1):\n        edges.append((i, i + 1))\n    next_label = path_count\n    remaining = n - next_label\n    # Allocate leaves: most to the ends, some to internal vertices\n    reserved_internal = remaining // 3\n    attach_to_ends = remaining - reserved_internal\n    left_leaves = attach_to_ends // 2\n    right_leaves = attach_to_ends - left_leaves\n    # Attach leaves to left end (vertex 0)\n    for _ in range(left_leaves):\n        edges.append((0, next_label))\n        next_label += 1\n    # Attach leaves to right end (vertex path_count-1)\n    for _ in range(right_leaves):\n        edges.append((path_count - 1, next_label))\n        next_label += 1\n    # Attach remaining leaves to internal vertices in a round-robin pattern\n    internal_vertices = [v for v in range(1, path_count - 1)]\n    if internal_vertices:\n        idx = 0\n        while next_label < n:\n            v = internal_vertices[idx % len(internal_vertices)]\n            edges.append((v, next_label))\n            next_label += 1\n            idx += 1\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.002689473330974579,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog3",
        "island_id": 3,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762890422.5869312,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen2_child1_0": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen2_child1_0",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    adj = [[] for _ in range(n)]\n    u = 0\n    idx = 0\n    while u < n:\n        r = n - u\n        if r == 1:\n            # single isolated vertex component\n            u += 1\n            idx += 1\n            continue\n\n        # Choose component type deterministically based on n and idx\n        # 0=path, 1=star, 2=broom, 3=double-broom\n        if r <= 3:\n            comp_choice = 0\n        elif r <= 5:\n            comp_choice = 1\n        elif r <= 7:\n            comp_choice = 2\n        else:\n            comp_choice = 3\n\n        if comp_choice == 0:\n            # simple path on r vertices\n            for i in range(u, u + r - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n            u += r\n            idx += 1\n            continue\n\n        if comp_choice == 1:\n            # star: center + r-1 leaves\n            center = u\n            for v in range(u + 1, u + r):\n                adj[center].append(v)\n                adj[v].append(center)\n            u += r\n            idx += 1\n            continue\n\n        if comp_choice == 2:\n            # broom: star + path starting at center\n            s = 2 + ((idx * 3 + n) % 3)  # leaves 2..4\n            p = 2 + ((idx + n) % 3)      # path vertices after center 2..4\n            total = 1 + s + p            # center + leaves + path vertices\n            if total > r:\n                extra = total - r\n                reduce_s = min(extra, max(0, s - 1))\n                s -= reduce_s\n                extra -= reduce_s\n                if extra > 0:\n                    reduce_p = min(extra, max(0, p - 1))\n                    p -= reduce_p\n                    extra -= reduce_p\n                total = 1 + s + p\n            if total > r or s < 1 or p < 1:\n                # fallback to a simple path on r vertices\n                for i in range(u, u + r - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n                u += r\n                idx += 1\n                continue\n            center = u\n            # connect star leaves\n            for v in range(u + 1, u + 1 + s):\n                adj[center].append(v)\n                adj[v].append(center)\n            # attach a path starting from center\n            first_chain = u + 1 + s\n            adj[center].append(first_chain)\n            adj[first_chain].append(center)\n            for i in range(first_chain, first_chain + p - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n            u += total\n            idx += 1\n            continue\n\n        # double-broom: two centers with leaves connected by a path\n        s1 = 2 + ((idx * 5 + n) % 4)       # left leaves: 2..5\n        s2 = 2 + ((idx * 3 + n * 2) % 4)   # right leaves: 2..5\n        p_int = 1 + ((idx + n) % 3)        # internal path vertices between centers: 1..3\n        total = 2 + s1 + s2 + p_int        # two centers + leaves + internal vertices\n\n        if total > r:\n            extra = total - r\n            # greedily reduce leaves more than path to keep the bridge\n            while extra > 0 and (s1 > 1 or s2 > 1 or p_int > 0):\n                if s1 >= s2 and s1 > 1:\n                    s1 -= 1\n                    extra -= 1\n                    continue\n                if s2 > 1:\n                    s2 -= 1\n                    extra -= 1\n                    continue\n                if p_int > 0:\n                    p_int -= 1\n                    extra -= 1\n            total = 2 + s1 + s2 + p_int\n\n        if total > r or s1 < 1 or s2 < 1 or p_int < 0:\n            # fallback: caterpillar-like component (path with extra leaves)\n            path_len = max(2, min(r - 1, (r // 2) + 1))\n            # build path\n            for i in range(u, u + path_len - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n            used = path_len\n            remaining = r - used\n            # attach remaining vertices as leaves along the path\n            if remaining > 0:\n                base = u\n                for j in range(remaining):\n                    leaf = u + used + j\n                    attach_to = base + (j % path_len)\n                    adj[attach_to].append(leaf)\n                    adj[leaf].append(attach_to)\n            u += r\n            idx += 1\n            continue\n\n        # assemble the double-broom component layout:\n        # [c1][left leaves s1][internal path p_int][c2][right leaves s2]\n        c1 = u\n        # connect left leaves\n        for v in range(u + 1, u + 1 + s1):\n            adj[c1].append(v)\n            adj[v].append(c1)\n        ip_start = u + 1 + s1\n        c2 = ip_start + p_int\n        # connect bridge from c1 to c2\n        if p_int == 0:\n            adj[c1].append(c2)\n            adj[c2].append(c1)\n        else:\n            # c1 to first internal\n            adj[c1].append(ip_start)\n            adj[ip_start].append(c1)\n            # internal chain\n            for i in range(ip_start, ip_start + p_int - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n            ip_end = ip_start + p_int - 1\n            # last internal to c2\n            adj[ip_end].append(c2)\n            adj[c2].append(ip_end)\n        # connect right leaves\n        for v in range(c2 + 1, c2 + 1 + s2):\n            adj[c2].append(v)\n            adj[v].append(c2)\n\n        u += total\n        idx += 1\n\n    return adj",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.003318674862384796,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "island_id": 1,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889942.7009957,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen2_child1_1": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen2_child1_1",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    # Build a forest composed of \"spider\" components (a center with multiple legs),\n    # with deterministic leg counts and lengths aimed to diversify independent-set behavior.\n    edges = []\n    u = 0\n    idx = 0\n    while u < n:\n        r = n - u\n        if r == 1:\n            # isolated vertex component\n            u += 1\n            idx += 1\n            continue\n        if r == 2:\n            # simple edge component\n            a, b = u, u + 1\n            edges.append((a, b))\n            u += 2\n            idx += 1\n            continue\n        if r <= 5:\n            # star component: center with r-1 leaves\n            center = u\n            for v in range(u + 1, u + r):\n                edges.append((center, v))\n            u += r\n            idx += 1\n            continue\n        # r >= 6: build a spider component (center + k legs of varying lengths)\n        k = 3 + ((idx * 3 + n) % 4)  # number of legs: 3..6\n        k = min(k, r - 1)            # cannot exceed available vertices\n        base = 1 + ((idx + n) % 2)   # base leg length: 1 or 2\n        pattern = [base, base + 1, base + 2, base + 1, base, base]\n        leg_lengths = pattern[:k]\n        total = 1 + sum(leg_lengths)  # center + legs vertices\n        if total > r:\n            # reduce leg lengths from the end to fit in remaining vertices\n            extra = total - r\n            for i in range(k - 1, -1, -1):\n                if extra <= 0:\n                    break\n                reducible = max(0, leg_lengths[i] - 1)\n                take = min(reducible, extra)\n                leg_lengths[i] -= take\n                extra -= take\n            total = 1 + sum(leg_lengths)\n            if total > r or any(L < 1 for L in leg_lengths):\n                # fallback: simple path on r vertices\n                for i in range(u, u + r - 1):\n                    edges.append((i, i + 1))\n                u += r\n                idx += 1\n                continue\n        center = u\n        cur = u + 1\n        # attach each leg\n        for L in leg_lengths:\n            first = cur\n            # connect center to the first vertex of the leg\n            edges.append((center, first))\n            # extend the leg as a path of length L\n            for i in range(first, first + L - 1):\n                edges.append((i, i + 1))\n            cur += L\n        u += 1 + sum(leg_lengths)\n        idx += 1\n    return edges",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.004536844789981842,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "island_id": 1,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889803.9586387,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "erdos_993_alphaevolve_counterexample_v1_gen2_child1_2": {
        "id": "erdos_993_alphaevolve_counterexample_v1_gen2_child1_2",
        "code": "def propose_forest_candidate(n: int):\n    if n <= 0:\n        return []\n    # Build a forest composed of \"spider\" components (one hub with multiple legs of varying lengths),\n    # plus small paths/stars when the remainder is small. Deterministic pattern via n and component index.\n    adj = [[] for _ in range(n)]\n    u = 0  # next unused vertex label\n    comp_idx = 0\n    while u < n:\n        r = n - u  # remaining vertices to allocate\n        if r == 1:\n            # isolated vertex\n            u += 1\n            comp_idx += 1\n            continue\n        if r <= 4:\n            # small path component to keep things simple and acyclic\n            for i in range(u, u + r - 1):\n                a, b = i, i + 1\n                adj[a].append(b)\n                adj[b].append(a)\n            u += r\n            comp_idx += 1\n            continue\n\n        # Build a spider component: one center with L legs, each leg is a path of certain length\n        center = u\n        # Choose number of legs L deterministically in 3..6\n        L = 3 + ((comp_idx + n) % 4)\n        # Initial leg lengths pattern in 1..4\n        leg_lengths = []\n        for i in range(L):\n            leg_lengths.append(1 + ((i + comp_idx + n) % 4))\n        total = 1 + sum(leg_lengths)\n\n        # Adjust down if we exceed available vertices\n        if total > r:\n            excess = total - r\n            # First, reduce legs longer than 1\n            i = L - 1\n            while excess > 0 and i >= 0:\n                if leg_lengths[i] > 1:\n                    reducible = min(excess, leg_lengths[i] - 1)\n                    leg_lengths[i] -= reducible\n                    excess -= reducible\n                i -= 1\n            total = 1 + sum(leg_lengths)\n            # If still exceeding, drop legs entirely (remove legs of length 1)\n            while total > r and len(leg_lengths) > 1:\n                # Drop the last leg\n                total -= leg_lengths.pop()\n            if total > r:\n                # Fallback: if still too large or only one leg left, make a simple path on r vertices\n                for i in range(u, u + r - 1):\n                    a, b = i, i + 1\n                    adj[a].append(b)\n                    adj[b].append(a)\n                u += r\n                comp_idx += 1\n                continue\n        else:\n            # If we have leftover vertices, distribute them by elongating legs cyclically\n            leftover = r - total\n            i = 0\n            while leftover > 0 and L > 0:\n                leg_lengths[i % L] += 1\n                leftover -= 1\n                i += 1\n            total = 1 + sum(leg_lengths)\n\n        # Build the spider with the finalized leg lengths\n        next_vertex = u + 1\n        for length in leg_lengths:\n            if length <= 0:\n                continue\n            # first vertex of the leg attaches to center\n            first = next_vertex\n            adj[center].append(first)\n            adj[first].append(center)\n            # chain along the leg\n            for j in range(length - 1):\n                a = next_vertex + j\n                b = next_vertex + j + 1\n                adj[a].append(b)\n                adj[b].append(a)\n            next_vertex += length\n\n        u += total\n        comp_idx += 1\n\n    return adj",
        "fitness_scores": {
            "correctness": 1.0,
            "runtime_ms": 0.006103515625,
            "passed_tests": 5.0,
            "total_tests": 5.0,
            "highest_level_passed": 0.0
        },
        "generation": 2,
        "parent_id": "erdos_993_alphaevolve_counterexample_v1_gen0_prog2",
        "island_id": 1,
        "errors": [],
        "status": "evaluated",
        "created_at": 1762889844.7635405,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog5": {
        "id": "generic_shortest_path_problem_gen0_prog5",
        "code": "def solve_shortest_paths(args):\n    import heapq\n\n    # Parse inputs\n    if not isinstance(args, (list, tuple)) or len(args) < 2:\n        return {}\n    graph = args[0] if isinstance(args[0], dict) else {}\n    start = args[1]\n\n    # Optional configuration\n    cfg = {}\n    if len(args) >= 3 and isinstance(args[2], dict):\n        cfg = args[2]\n    max_relaxations = cfg.get(\"max_relaxations\", None)\n    max_pops = cfg.get(\"max_pops\", None)\n    # No-op logger by default\n    log_fn = cfg.get(\"log_fn\", None)\n    def log(*_a, **_k):\n        if callable(log_fn):\n            try:\n                log_fn(*_a, **_k)\n            except Exception:\n                pass\n\n    # Collect all nodes (including implicit ones and the start)\n    nodes = set(graph.keys())\n    for u in graph:\n        neighbors = graph.get(u, {})\n        if isinstance(neighbors, dict):\n            nodes.update(neighbors.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0.0, start)]\n    relaxations = 0\n    pops = 0\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        pops += 1\n        if max_pops is not None and pops > max_pops:\n            break\n        # Skip if this entry is stale\n        if d != dist[u]:\n            continue\n        # Traverse neighbors\n        for v, w in graph.get(u, {}).items():\n            try:\n                weight = float(w)\n            except Exception:\n                # If weight is not a number, skip this edge\n                continue\n            nd = d + weight\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n                relaxations += 1\n                if max_relaxations is not None and relaxations > max_relaxations:\n                    log(\"Relaxation budget exceeded; returning partial results.\")\n                    heap = []\n                    break\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395606.0682895,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "systems_builder"
    },
    "generic_shortest_path_problem_gen0_prog6": {
        "id": "generic_shortest_path_problem_gen0_prog6",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    graph, start = data\n\n    nodes = set(graph.keys())\n    for u in graph:\n        nodes.update(graph[u].keys())\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    result = {}\n    for node, d in dist.items():\n        if d == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = d\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3246012,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog7": {
        "id": "generic_shortest_path_problem_gen0_prog7",
        "code": "def solve_shortest_paths(graph_or_pair, start=None):\n    import heapq\n\n    # Support both signatures: (graph, start) or ([graph, start]/(graph, start))\n    if start is None:\n        if isinstance(graph_or_pair, (list, tuple)) and len(graph_or_pair) == 2:\n            graph, start = graph_or_pair\n        else:\n            return None\n    else:\n        graph = graph_or_pair\n\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3257523,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog8": {
        "id": "generic_shortest_path_problem_gen0_prog8",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    # Validate input structure\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Build ordered list of all nodes: graph keys first, then neighbors, then ensure start included\n    nodes_order = []\n    seen_nodes = set()\n\n    def add_node(n):\n        if n not in seen_nodes:\n            seen_nodes.add(n)\n            nodes_order.append(n)\n\n    # Add nodes from graph keys preserving insertion order\n    for node in graph.keys():\n        add_node(node)\n\n    # Validate edges and add neighbor nodes preserving insertion order\n    for node, edges in graph.items():\n        if not isinstance(edges, dict):\n            return None\n        for neighbor in edges.keys():\n            add_node(neighbor)\n\n    # Ensure start is included\n    add_node(start)\n\n    # Initialize distances\n    inf = float('inf')\n    dist = {n: inf for n in nodes_order}\n    dist[start] = 0\n\n    # Ensure adjacency for all nodes\n    adjacency = {}\n    for n in nodes_order:\n        edges = graph.get(n, {})\n        if edges is None:\n            adjacency[n] = {}\n        elif isinstance(edges, dict):\n            adjacency[n] = edges\n        else:\n            return None\n\n    # Dijkstra's algorithm using a heap with a tie-breaker to avoid comparing nodes\n    heap = []\n    counter = 0\n    heapq.heappush(heap, (0, counter, start))\n    counter += 1\n\n    while heap:\n        d, _, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        edges = adjacency.get(u, {})\n        for v, w in edges.items():\n            if not isinstance(w, (int, float)):\n                return None\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, counter, v))\n                counter += 1\n\n    # Prepare result with \"float('inf')\" string for unreachable nodes\n    result = {}\n    for n in nodes_order:\n        val = dist[n]\n        result[n] = val if val != inf else \"float('inf')\"\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3269088,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog9": {
        "id": "generic_shortest_path_problem_gen0_prog9",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    # Collect all nodes including those appearing only as neighbors\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u, neighbors in graph.items():\n            if isinstance(neighbors, dict):\n                nodes.update(neighbors.keys())\n    else:\n        # If graph is not a dict, treat as empty\n        graph = {}\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra (distance, node)\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.328071,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog10": {
        "id": "generic_shortest_path_problem_gen0_prog10",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n    if graph is None:\n        graph = {}\n    if start is None:\n        return None\n\n    # Collect all nodes: keys in graph, neighbors in adjacency lists, and the start node\n    nodes = set()\n    nodes.update(graph.keys())\n    for u in graph:\n        nbrs = graph.get(u, {})\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0, start)]\n    while heap:\n        cur_d, u = heapq.heappop(heap)\n        if cur_d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = cur_d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Convert unreachable distances to the string representation per examples\n    result = {}\n    for node in nodes:\n        if dist[node] == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = dist[node]\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3292384,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog11": {
        "id": "generic_shortest_path_problem_gen0_prog11",
        "code": "def solve_shortest_paths(data):\n    from heapq import heappush, heappop\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n    if graph is None:\n        graph = {}\n    if not isinstance(graph, dict):\n        return None\n    nodes = set()\n    for u, nbrs in graph.items():\n        nodes.add(u)\n        if isinstance(nbrs, dict):\n            for v in nbrs.keys():\n                nodes.add(v)\n    nodes.add(start)\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n    heap = [(0, start)]\n    while heap:\n        d, u = heappop(heap)\n        if d != dist.get(u, INF):\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            continue\n        for v, w in nbrs.items():\n            try:\n                newd = d + w\n            except Exception:\n                continue\n            if newd < dist[v]:\n                dist[v] = newd\n                heappush(heap, (newd, v))\n    result = {}\n    for node in nodes:\n        d = dist[node]\n        if d == INF:\n            result[node] = \"float('inf')\"\n        else:\n            if isinstance(d, float) and d.is_integer():\n                result[node] = int(d)\n            else:\n                result[node] = d\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3303466,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog12": {
        "id": "generic_shortest_path_problem_gen0_prog12",
        "code": "from heapq import heappush, heappop\n\ndef solve_shortest_paths(data):\n    graph, start = data\n    nodes = set()\n    for u, edges in graph.items():\n        nodes.add(u)\n        for v in edges:\n            nodes.add(v)\n    nodes.add(start)\n\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heappop(heap)\n        if d > dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            try:\n                nd = d + w\n            except TypeError:\n                continue\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(heap, (nd, v))\n\n    result = {}\n    for node in nodes:\n        val = dist[node]\n        if val == INF:\n            result[node] = \"float('inf')\"\n        else:\n            if isinstance(val, float) and val.is_integer():\n                result[node] = int(val)\n            else:\n                result[node] = val\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.331532,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog13": {
        "id": "generic_shortest_path_problem_gen0_prog13",
        "code": "def solve_shortest_paths(input_data):\n    from heapq import heappush, heappop\n\n    # Parse input\n    try:\n        graph, start = input_data\n    except Exception:\n        return None\n\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Collect all nodes (including those only in adjacency lists and the start node)\n    nodes = set()\n    for u, nbrs in graph.items():\n        nodes.add(u)\n        if isinstance(nbrs, dict):\n            for v in nbrs.keys():\n                nodes.add(v)\n    nodes.add(start)\n\n    INF = float('inf')\n    dist = {n: INF for n in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heappop(heap)\n        if d > dist[u]:\n            continue\n\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            continue\n\n        for v, w in nbrs.items():\n            try:\n                nd = d + w\n            except Exception:\n                continue\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(heap, (nd, v))\n\n    result = {}\n    for n in nodes:\n        val = dist[n]\n        if val == INF:\n            result[n] = \"float('inf')\"\n        else:\n            if isinstance(val, float) and val.is_integer():\n                result[n] = int(val)\n            else:\n                result[n] = val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3327973,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog14": {
        "id": "generic_shortest_path_problem_gen0_prog14",
        "code": "from heapq import heappush, heappop\n\ndef solve_shortest_paths(*args):\n    # Parse inputs flexibly: either (graph, start) or ([graph, start],)\n    if len(args) == 1 and isinstance(args[0], (list, tuple)) and len(args[0]) == 2:\n        graph, start = args[0]\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes: keys of graph and all neighbor keys, plus start\n    all_nodes = set(graph.keys())\n    for u in graph.values():\n        if not isinstance(u, dict):\n            return None\n        all_nodes.update(u.keys())\n    all_nodes.add(start)\n\n    # Validate weights and ensure non-negative for Dijkstra\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        for v, w in nbrs.items():\n            if not isinstance(w, (int, float)):\n                return None\n            if w < 0:\n                return None\n\n    # Initialize distances\n    inf = float('inf')\n    dist = {node: inf for node in all_nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3339686,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog15": {
        "id": "generic_shortest_path_problem_gen0_prog15",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs flexibly: either (graph, start) or ([graph, start])\n    if len(args) == 1:\n        data = args[0]\n        if not isinstance(data, (list, tuple)) or len(data) != 2:\n            return None\n        graph, start = data\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Build the set of all nodes (including implicit nodes and the start node)\n    nodes = set(graph.keys())\n    for v in graph.values():\n        if not isinstance(v, dict):\n            return None\n        nodes.update(v.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    INF_STR = \"float('inf')\"\n    distances = {node: float('inf') for node in nodes}\n    distances[start] = 0.0\n\n    # Dijkstra's algorithm with a priority queue\n    heap = [(0.0, start)]\n    while heap:\n        dist_u, u = heapq.heappop(heap)\n        if dist_u != distances[u]:\n            continue\n        # Get neighbors; if u not in graph or has no outgoing edges, treat as empty\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            return None\n        for v, w in neighbors.items():\n            # Validate weight\n            if not isinstance(w, (int, float)):\n                return None\n            # Standard Dijkstra relaxation\n            nd = dist_u + w\n            if nd < distances[v]:\n                distances[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Prepare output with required infinity representation\n    result = {}\n    for node in nodes:\n        d = distances[node]\n        if d == float('inf'):\n            result[node] = INF_STR\n        else:\n            # Normalize integer-valued floats to int\n            if isinstance(d, float) and d.is_integer():\n                result[node] = int(d)\n            else:\n                result[node] = d\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3352256,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog16": {
        "id": "generic_shortest_path_problem_gen0_prog16",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    if len(args) == 1:\n        data = args[0]\n        if isinstance(data, (list, tuple)) and len(data) == 2:\n            graph, start = data\n        else:\n            return None\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if graph is None:\n        graph = {}\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    get_neighbors = lambda u: graph.get(u, {}) if isinstance(graph.get(u, {}), dict) else {}\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist.get(u, float('inf')):\n            continue\n        for v, w in get_neighbors(u).items():\n            try:\n                alt = d + w\n            except TypeError:\n                continue\n            if alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(heap, (alt, v))\n\n    result = {}\n    for node in nodes:\n        val = dist[node]\n        if val == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            if isinstance(val, float) and val.is_integer():\n                val = int(val)\n            result[node] = val\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.336506,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog17": {
        "id": "generic_shortest_path_problem_gen0_prog17",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    if len(args) == 1:\n        param = args[0]\n        if not isinstance(param, (list, tuple)) or len(param) < 2:\n            return None\n        graph, start = param[0], param[1]\n    elif len(args) >= 2:\n        graph, start = args[0], args[1]\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    dist = {n: float('inf') for n in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            try:\n                nd = d + w\n            except TypeError:\n                continue\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    result = {}\n    for n in nodes:\n        if dist[n] == float('inf'):\n            result[n] = \"float('inf')\"\n        else:\n            val = dist[n]\n            if isinstance(val, float) and val.is_integer():\n                result[n] = int(val)\n            else:\n                result[n] = val\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3378048,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog18": {
        "id": "generic_shortest_path_problem_gen0_prog18",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes (including those only mentioned as neighbors) and ensure start is included\n    nodes = set(graph.keys())\n    for adj in graph.values():\n        if isinstance(adj, dict):\n            nodes.update(adj.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra's algorithm\n    heap = [(0, start)]\n\n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist[u]:\n            continue\n\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            neighbors = {}\n\n        for v, w in neighbors.items():\n            # Skip invalid weights\n            if not isinstance(w, (int, float)):\n                continue\n            new_dist = current_dist + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(heap, (new_dist, v))\n\n    # Convert unreachable distances to the string \"float('inf')\"\n    result = {}\n    for node in nodes:\n        if dist[node] == INF:\n            result[node] = \"float('inf')\"\n        else:\n            # Return int if it's an integer distance, else float\n            val = dist[node]\n            result[node] = int(val) if isinstance(val, float) and val.is_integer() else val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3391106,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog19": {
        "id": "generic_shortest_path_problem_gen0_prog19",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs to obtain graph and start node\n    graph = None\n    start = None\n    if len(args) == 2:\n        graph, start = args\n    elif len(args) == 1:\n        data = args[0]\n        if isinstance(data, (list, tuple)) and len(data) == 2:\n            graph, start = data\n    if not isinstance(graph, dict) or start is None:\n        return None\n\n    # Collect all nodes (including those only appearing as neighbors and the start node)\n    nodes = set(graph.keys())\n    for neighbors in graph.values():\n        if isinstance(neighbors, dict):\n            nodes.update(neighbors.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra's algorithm\n    heap = [(0, start)]\n\n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist[u]:\n            continue\n\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            neighbors = {}\n\n        for v, w in neighbors.items():\n            # Ensure weight is numeric\n            if not isinstance(w, (int, float)):\n                continue\n            new_dist = current_dist + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(heap, (new_dist, v))\n\n    # Convert distances to integers where applicable\n    result = {}\n    for node, d in dist.items():\n        if d == INF:\n            result[node] = INF\n        else:\n            # Cast to int if it's an integer value\n            result[node] = int(d) if isinstance(d, float) and d.is_integer() else d\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3403952,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog20": {
        "id": "generic_shortest_path_problem_gen0_prog20",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        for v, w in nbrs.items():\n            nodes.add(v)\n            if not isinstance(w, (int, float)) or w < 0:\n                return None\n\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    heap = [(0.0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3416407,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog21": {
        "id": "generic_shortest_path_problem_gen0_prog21",
        "code": "def solve_shortest_paths(args):\n    from heapq import heappush, heappop\n\n    graph, start = args\n\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for neighbors in graph.values():\n            if isinstance(neighbors, dict):\n                nodes.update(neighbors.keys())\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        current_dist, u = heappop(heap)\n        if current_dist != dist[u]:\n            continue\n        neighbors = graph.get(u, {})\n        for v, w in neighbors.items():\n            new_dist = current_dist + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heappush(heap, (new_dist, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.34389,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog22": {
        "id": "generic_shortest_path_problem_gen0_prog22",
        "code": "def solve_shortest_paths(graph_and_start):\n    import heapq\n\n    if not isinstance(graph_and_start, (list, tuple)) or len(graph_and_start) != 2:\n        return None\n    graph, start = graph_and_start\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set()\n    for node, neighbors in graph.items():\n        nodes.add(node)\n        if not isinstance(neighbors, dict):\n            return None\n        for nbr, w in neighbors.items():\n            nodes.add(nbr)\n            if not isinstance(w, (int, float)):\n                return None\n            if w < 0:\n                return None\n\n    nodes.add(start)\n\n    inf = float('inf')\n    dist = {node: inf for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    result = {}\n    for node in nodes:\n        if dist[node] == inf:\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = dist[node]\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.345197,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog23": {
        "id": "generic_shortest_path_problem_gen0_prog23",
        "code": "def solve_shortest_paths(*args):\n    from heapq import heappush, heappop\n\n    if len(args) == 1:\n        data = args[0]\n        if not isinstance(data, (list, tuple)) or len(data) != 2:\n            return None\n        graph, start = data\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if graph is None:\n        graph = {}\n    if start is None:\n        return None\n\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for _, nbrs in graph.items():\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heappop(heap)\n        if d != dist.get(u, float('inf')):\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            try:\n                nd = d + w\n            except Exception:\n                continue\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(heap, (nd, v))\n\n    result = {}\n    for node in nodes:\n        val = dist[node]\n        if val == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            if isinstance(val, float) and val.is_integer():\n                result[node] = int(val)\n            else:\n                result[node] = val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3465688,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog24": {
        "id": "generic_shortest_path_problem_gen0_prog24",
        "code": "def solve_shortest_paths(input_data):\n    from heapq import heappush, heappop\n\n    # Parse input\n    if isinstance(input_data, (list, tuple)) and len(input_data) == 2:\n        graph, start = input_data\n    else:\n        return None\n\n    if graph is None:\n        graph = {}\n\n    # Ensure graph is a dict\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes, including those appearing only as neighbors and the start node\n    nodes = set()\n    for u, nbrs in graph.items():\n        nodes.add(u)\n        if isinstance(nbrs, dict):\n            for v in nbrs.keys():\n                nodes.add(v)\n    nodes.add(start)\n\n    # Initialize distances\n    inf = float('inf')\n    dist = {node: inf for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heappop(heap)\n        if d != dist.get(u, inf):\n            continue\n\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            continue\n\n        for v, w in neighbors.items():\n            # Skip invalid weights\n            try:\n                new_d = d + w\n            except Exception:\n                continue\n\n            if new_d < dist.get(v, inf):\n                dist[v] = new_d\n                heappush(heap, (new_d, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3479888,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog25": {
        "id": "generic_shortest_path_problem_gen0_prog25",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs to get graph and start node\n    graph = {}\n    start = None\n    if len(args) == 1:\n        data = args[0]\n        if isinstance(data, (list, tuple)) and len(data) == 2:\n            graph, start = data[0] if isinstance(data[0], dict) else {}, data[1]\n        elif isinstance(data, dict):\n            graph = data\n    elif len(args) >= 2:\n        graph = args[0] if isinstance(args[0], dict) else {}\n        start = args[1]\n\n    if start is None:\n        return None\n\n    # Collect all nodes (explicit keys and implicit neighbor keys), plus start\n    nodes = set()\n    nodes.add(start)\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u, nbrs in graph.items():\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            neighbors = {}\n        for v, w in neighbors.items():\n            if not isinstance(w, (int, float)):\n                continue\n            nd = d + w\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Prepare result with \"float('inf')\" for unreachable nodes\n    result = {}\n    for node in nodes:\n        if dist[node] == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            # Keep numeric type (int/float) as computed\n            result[node] = dist[node]\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.349382,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog26": {
        "id": "generic_shortest_path_problem_gen0_prog26",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n    graph, start = input_data\n\n    nodes = set([start])\n    for u, nbrs in graph.items():\n        nodes.add(u)\n        for v in nbrs:\n            nodes.add(v)\n\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    result = {}\n    for node in nodes:\n        val = dist[node]\n        result[node] = val if val != INF else \"float('inf')\"\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.350742,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog27": {
        "id": "generic_shortest_path_problem_gen0_prog27",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n    if not isinstance(input_data, (list, tuple)) or len(input_data) != 2:\n        return None\n\n    graph, start = input_data\n\n    # Collect all nodes: keys of graph, all neighbors in inner dicts, and the start node\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u, nbrs in graph.items():\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # If graph isn't a dict, just return start node distance\n    if not isinstance(graph, dict):\n        return {start: 0}\n\n    # Initialize distances\n    dist = {n: float('inf') for n in nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm using a priority queue\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            try:\n                nd = d + w\n            except Exception:\n                continue\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    # Prepare output: use \"float('inf')\" string for unreachable nodes\n    result = {}\n    for n in nodes:\n        val = dist[n]\n        if val == float('inf'):\n            result[n] = \"float('inf')\"\n        else:\n            result[n] = int(val) if isinstance(val, float) and val.is_integer() else val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.352078,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog28": {
        "id": "generic_shortest_path_problem_gen0_prog28",
        "code": "def solve_shortest_paths(data):\n    from heapq import heappush, heappop\n\n    graph, start = data\n    if graph is None:\n        graph = {}\n\n    nodes = set()\n    nodes.update(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(heap, (nd, v))\n\n    result = {}\n    for node in nodes:\n        if dist[node] == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = dist[node]\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3534372,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog29": {
        "id": "generic_shortest_path_problem_gen0_prog29",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    # Validate input format\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n\n    # If graph is not a dict, treat as empty graph\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Collect all nodes (including those appearing only as neighbors and the start)\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Dijkstra's algorithm\n    inf = float('inf')\n    dist = {node: inf for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Format output: use string \"float('inf')\" for unreachable nodes\n    result = {}\n    for node in nodes:\n        if dist[node] == inf:\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = dist[node]\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.354849,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog30": {
        "id": "generic_shortest_path_problem_gen0_prog30",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    # Basic validation\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes: keys of graph, keys of inner dicts, and the start node\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n        else:\n            # If inner structure is not a dict, treat as no outgoing edges\n            pass\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Dijkstra's algorithm using a priority queue\n    heap = [(0.0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        nbrs = graph.get(u, {})\n        if isinstance(nbrs, dict):\n            for v, w in nbrs.items():\n                try:\n                    nd = d + w\n                except Exception:\n                    continue\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heapq.heappush(heap, (nd, v))\n\n    # Prepare result with specified infinity representation\n    result = {}\n    for node in nodes:\n        d = dist[node]\n        if d == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            # Cast to int if the distance is an integer value\n            if isinstance(d, float) and d.is_integer():\n                result[node] = int(d)\n            else:\n                result[node] = d\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3563735,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog31": {
        "id": "generic_shortest_path_problem_gen0_prog31",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs\n    if len(args) == 1:\n        data = args[0]\n        if isinstance(data, (list, tuple)) and len(data) >= 2:\n            graph, start = data[0], data[1]\n        else:\n            return None\n    elif len(args) >= 2:\n        graph, start = args[0], args[1]\n    else:\n        return None\n\n    # Validate graph\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes, including those appearing only as neighbors\n    nodes = set()\n    for u, nbrs in graph.items():\n        nodes.add(u)\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Dijkstra's algorithm with a min-heap\n    heap = [(0.0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            # Skip non-numeric weights\n            try:\n                weight = float(w)\n            except (TypeError, ValueError):\n                continue\n            nd = d + weight\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3579214,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog32": {
        "id": "generic_shortest_path_problem_gen0_prog32",
        "code": "def solve_shortest_paths(data):\n    from heapq import heappush, heappop\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n    if graph is None:\n        graph = {}\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    pq = [(0, start)]\n    while pq:\n        d, u = heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(pq, (nd, v))\n\n    result = {}\n    for node in nodes:\n        if dist[node] == INF:\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = dist[node]\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3594422,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog33": {
        "id": "generic_shortest_path_problem_gen0_prog33",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs flexibly: either (graph, start) or ([graph, start])\n    if len(args) == 1 and isinstance(args[0], (list, tuple)) and len(args[0]) == 2:\n        graph, start = args[0]\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Collect nodes in a deterministic order: start, then graph keys, then neighbor keys\n    seen = set()\n    ordered_nodes = []\n\n    def add_node(n):\n        if n not in seen:\n            seen.add(n)\n            ordered_nodes.append(n)\n\n    add_node(start)\n    for u, nbrs in graph.items():\n        add_node(u)\n        if isinstance(nbrs, dict):\n            for v in nbrs.keys():\n                add_node(v)\n\n    # Initialize distances\n    dist = {n: float('inf') for n in ordered_nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm using a priority queue\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    # Prepare result with special handling for infinity\n    result = {}\n    for n in ordered_nodes:\n        val = dist[n]\n        if val == float('inf'):\n            result[n] = \"float('inf')\"\n        else:\n            if isinstance(val, float) and val.is_integer():\n                result[n] = int(val)\n            else:\n                result[n] = val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3608708,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog34": {
        "id": "generic_shortest_path_problem_gen0_prog34",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs to support either (graph, start) or ([graph, start])\n    if len(args) == 1 and isinstance(args[0], (list, tuple)) and len(args[0]) == 2:\n        graph, start = args[0]\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes: keys of graph, all neighbors, and the start node\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra\n    pq = [(0, start)]\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n\n        for v, w in nbrs.items():\n            try:\n                nd = d + w\n            except Exception:\n                return None\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3623378,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog35": {
        "id": "generic_shortest_path_problem_gen0_prog35",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Parse inputs\n    if len(args) == 1 and isinstance(args[0], (list, tuple)) and len(args[0]) == 2:\n        graph, start = args[0]\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes including those only appearing as neighbors, and ensure start is included\n    nodes = set(graph.keys())\n    for adj in graph.values():\n        if isinstance(adj, dict):\n            nodes.update(adj.keys())\n        else:\n            return None\n    nodes.add(start)\n\n    # Build adjacency mapping ensuring missing nodes have empty adjacency dicts\n    adjacency = {u: (graph.get(u, {}) if isinstance(graph.get(u, {}), dict) else {}) for u in nodes}\n\n    # Dijkstra's algorithm\n    dist = {u: float('inf') for u in nodes}\n    dist[start] = 0\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in adjacency[u].items():\n            try:\n                # Ensure weight is numeric\n                w_num = float(w)\n            except (TypeError, ValueError):\n                return None\n            nd = d + w_num\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Prepare result with string representation for infinity\n    result = {}\n    for node in nodes:\n        if dist[node] == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            # Convert to int if it's an integer value to match examples, otherwise keep float\n            val = dist[node]\n            if val.is_integer():\n                result[node] = int(val)\n            else:\n                result[node] = val\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3638003,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog36": {
        "id": "generic_shortest_path_problem_gen0_prog36",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes: keys of graph, keys of inner dicts, and start node\n    nodes = set(graph.keys())\n    for u in graph.values():\n        if isinstance(u, dict):\n            nodes.update(u.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm with min-heap\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            neighbors = {}\n        for v, w in neighbors.items():\n            try:\n                new_d = d + w\n            except TypeError:\n                # If weight isn't numeric, skip this edge\n                continue\n            if new_d < dist[v]:\n                dist[v] = new_d\n                heapq.heappush(heap, (new_d, v))\n\n    # Convert unreachable distances to the specified string representation\n    result = {}\n    for node in nodes:\n        if dist[node] == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            # Prefer int if integral\n            val = dist[node]\n            if isinstance(val, float) and val.is_integer():\n                val = int(val)\n            result[node] = val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3653135,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog37": {
        "id": "generic_shortest_path_problem_gen0_prog37",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    # Validate input format\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n    graph, start = data\n\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Collect all nodes, including those only in neighbor dictionaries and the start node\n    nodes = set(graph.keys())\n    for u, neighbors in graph.items():\n        if isinstance(neighbors, dict):\n            nodes.update(neighbors.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    INF = float('inf')\n    dist = {node: INF for node in nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0, start)]\n    visited = set()\n\n    while heap:\n        d_u, u = heapq.heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n\n        # If current distance is greater than recorded, skip\n        if d_u > dist[u]:\n            continue\n\n        neighbors = graph.get(u, {})\n        if not isinstance(neighbors, dict):\n            neighbors = {}\n\n        for v, w in neighbors.items():\n            if w < 0:\n                # Dijkstra's algorithm doesn't support negative weights; return None to indicate invalid input\n                return None\n            new_dist = d_u + w\n            if new_dist < dist.get(v, INF):\n                dist[v] = new_dist\n                heapq.heappush(heap, (new_dist, v))\n\n    # Convert unreachable distances to string representation\n    result = {}\n    for node in nodes:\n        if dist[node] == INF:\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = dist[node]\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.366946,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog38": {
        "id": "generic_shortest_path_problem_gen0_prog38",
        "code": "def solve_shortest_paths(inp):\n    import heapq\n\n    if not isinstance(inp, (list, tuple)) or len(inp) != 2:\n        return None\n    graph, start = inp\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set([start])\n    for u, nbrs in graph.items():\n        nodes.add(u)\n        if not isinstance(nbrs, dict):\n            return None\n        for v in nbrs.keys():\n            nodes.add(v)\n\n    INF = float('inf')\n    dist = {n: INF for n in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            if not isinstance(w, (int, float)):\n                return None\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    result = {}\n    for n in nodes:\n        result[n] = dist[n] if dist[n] != INF else \"float('inf')\"\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3686078,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog39": {
        "id": "generic_shortest_path_problem_gen0_prog39",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    graph, start = data\n\n    # Collect all nodes (graph keys, neighbor keys, and start)\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for u, nbrs in graph.items():\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Dijkstra's algorithm using min-heap\n    heap = [(0, start)]\n    visited = set()\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n        if d > dist[u]:\n            continue\n\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    # Prepare result with string for infinity\n    result = {}\n    for node in nodes:\n        val = dist.get(node, float('inf'))\n        if val == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            if isinstance(val, float) and val.is_integer():\n                result[node] = int(val)\n            else:\n                result[node] = val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3702478,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog40": {
        "id": "generic_shortest_path_problem_gen0_prog40",
        "code": "def solve_shortest_paths(data):\n    from heapq import heappush, heappop\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n\n    if not isinstance(graph, dict):\n        graph = {}\n\n    nodes = set(graph.keys())\n    for adj in graph.values():\n        if isinstance(adj, dict):\n            nodes.update(adj.keys())\n    nodes.add(start)\n\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        d, u = heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heappush(heap, (nd, v))\n\n    result = {}\n    for node in nodes:\n        val = dist[node]\n        result[node] = val if val != float('inf') else \"float('inf')\"\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3718154,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog41": {
        "id": "generic_shortest_path_problem_gen0_prog41",
        "code": "def solve_shortest_paths(data, start=None):\n    import heapq\n\n    # Parse arguments: allow either (graph, start) or [graph, start]\n    if start is None and isinstance(data, (list, tuple)) and len(data) == 2:\n        graph, start_node = data\n    else:\n        graph = data\n        start_node = start\n\n    # Basic validation\n    if not isinstance(graph, dict) or start_node is None:\n        return None\n\n    # Collect all nodes (keys of graph and all neighbor keys), ensure start is included\n    nodes = set(graph.keys())\n    for adj in graph.values():\n        if isinstance(adj, dict):\n            nodes.update(adj.keys())\n    nodes.add(start_node)\n\n    # Initialize distances\n    inf = float('inf')\n    dist = {node: inf for node in nodes}\n    dist[start_node] = 0\n\n    # Priority queue for Dijkstra\n    pq = [(0, start_node)]\n\n    def get_neighbors(u):\n        adj = graph.get(u)\n        if isinstance(adj, dict):\n            return adj.items()\n        return ()\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in get_neighbors(u):\n            try:\n                nd = d + w\n            except Exception:\n                return None\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.373352,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog42": {
        "id": "generic_shortest_path_problem_gen0_prog42",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    # Validate input format: expected [graph, start]\n    if not (isinstance(data, (list, tuple)) and len(data) == 2 and isinstance(data[0], dict)):\n        return None\n\n    graph, start = data\n    # Collect all nodes (including implicit ones and the start node)\n    nodes = set(graph.keys())\n    for u in graph.values():\n        nodes.update(u.keys())\n    nodes.add(start)\n\n    # Detect negative edge weights\n    has_negative = any(\n        (isinstance(w, (int, float)) and w < 0)\n        for u in graph.values()\n        for w in u.values()\n    )\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    if has_negative:\n        # Bellman-Ford for graphs with negative weights\n        n = len(nodes)\n        # Relax edges up to n-1 times\n        for _ in range(n - 1):\n            updated = False\n            for u in nodes:\n                if dist[u] == float('inf'):\n                    continue\n                for v, w in graph.get(u, {}).items():\n                    if dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n                        updated = True\n            if not updated:\n                break\n        # Check for negative cycles reachable from start\n        for u in nodes:\n            if dist[u] == float('inf'):\n                continue\n            for v, w in graph.get(u, {}).items():\n                if dist[u] + w < dist[v]:\n                    return None\n    else:\n        # Dijkstra's algorithm for non-negative weights\n        heap = [(0.0, start)]\n        visited = set()\n        while heap:\n            d, u = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add(u)\n            if d > dist[u]:\n                continue\n            for v, w in graph.get(u, {}).items():\n                nd = d + w\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heapq.heappush(heap, (nd, v))\n\n    # Build result with required infinity representation\n    result = {}\n    for node in nodes:\n        if dist[node] == float('inf'):\n            result[node] = \"float('inf')\"\n        else:\n            # Return as int if it's an integer value, else float\n            val = dist[node]\n            result[node] = int(val) if isinstance(val, float) and val.is_integer() else val\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3749468,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog43": {
        "id": "generic_shortest_path_problem_gen0_prog43",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        return None\n\n    graph, start = data\n\n    if not isinstance(graph, dict):\n        return None\n\n    # Collect all nodes including those that appear only as neighbors\n    nodes = set(graph.keys())\n    for u, edges in graph.items():\n        if isinstance(edges, dict):\n            nodes.update(edges.keys())\n\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra's algorithm\n    heap = [(0, start)]  # (distance, node)\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.377634,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog44": {
        "id": "generic_shortest_path_problem_gen0_prog44",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    if len(args) == 1:\n        inp = args[0]\n        if isinstance(inp, (list, tuple)) and len(inp) == 2:\n            graph, start = inp\n        else:\n            return None\n    elif len(args) == 2:\n        graph, start = args\n    else:\n        return None\n\n    if not isinstance(graph, dict):\n        return None\n    try:\n        hash(start)\n    except Exception:\n        return None\n\n    nodes = set(graph.keys())\n    for u, nbrs in graph.items():\n        if not isinstance(nbrs, dict):\n            return None\n        for v, w in nbrs.items():\n            nodes.add(v)\n            if not isinstance(w, (int, float)):\n                return None\n    nodes.add(start)\n\n    inf = float('inf')\n    dist = {node: inf for node in nodes}\n    dist[start] = 0\n\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in graph.get(u, {}).items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3794,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog45": {
        "id": "generic_shortest_path_problem_gen0_prog45",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n    if not isinstance(input_data, (list, tuple)) or len(input_data) != 2:\n        return None\n\n    graph, start = input_data\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Collect all nodes: keys and all neighbors\n    nodes = set(graph.keys())\n    has_negative = False\n    for u, nbrs in graph.items():\n        if isinstance(nbrs, dict):\n            nodes.update(nbrs.keys())\n            for w in nbrs.values():\n                if isinstance(w, (int, float)) and w < 0:\n                    has_negative = True\n        else:\n            # If nbrs is not a dict, treat as no outgoing edges\n            pass\n\n    nodes.add(start)\n\n    inf = float('inf')\n\n    # If there are negative weights, use Bellman-Ford\n    if has_negative:\n        dist = {node: inf for node in nodes}\n        dist[start] = 0\n\n        edges = []\n        for u, nbrs in graph.items():\n            if not isinstance(nbrs, dict):\n                continue\n            for v, w in nbrs.items():\n                edges.append((u, v, w))\n\n        # Relax edges |V|-1 times\n        for _ in range(max(0, len(nodes) - 1)):\n            updated = False\n            for u, v, w in edges:\n                if dist.get(u, inf) != inf:\n                    nd = dist[u] + w\n                    if nd < dist.get(v, inf):\n                        dist[v] = nd\n                        updated = True\n            if not updated:\n                break\n\n        # Check for negative-weight cycles reachable from start\n        for u, v, w in edges:\n            if dist.get(u, inf) != inf and dist[u] + w < dist.get(v, inf):\n                return None\n\n        # Prepare result, converting unreachable to \"float('inf')\"\n        result = {}\n        for node in nodes:\n            d = dist.get(node, inf)\n            if d == inf:\n                result[node] = \"float('inf')\"\n            else:\n                result[node] = d\n        return result\n\n    # Dijkstra's algorithm for non-negative weights\n    dist = {node: inf for node in nodes}\n    dist[start] = 0\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist.get(u, inf):\n            continue\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            continue\n        for v, w in nbrs.items():\n            nd = d + w\n            if nd < dist.get(v, inf):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    result = {}\n    for node in nodes:\n        d = dist.get(node, inf)\n        if d == inf:\n            result[node] = \"float('inf')\"\n        else:\n            result[node] = d\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3811467,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog46": {
        "id": "generic_shortest_path_problem_gen0_prog46",
        "code": "def solve_shortest_paths(data):\n    import heapq\n\n    if not isinstance(data, (list, tuple)) or len(data) != 2:\n        raise ValueError(\"Expected input as [graph_dict, start_node]\")\n\n    graph, start = data\n    if graph is None:\n        graph = {}\n\n    # Collect all nodes: keys of graph plus all neighbors, and ensure start is included\n    nodes = set()\n    if isinstance(graph, dict):\n        nodes.update(graph.keys())\n        for nbrs in graph.values():\n            if isinstance(nbrs, dict):\n                nodes.update(nbrs.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0\n\n    # Priority queue for Dijkstra\n    heap = [(0, start)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            continue\n\n        for v, w in nbrs.items():\n            try:\n                nd = d + w\n            except TypeError:\n                # Skip edges with non-numeric weights\n                continue\n\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3828764,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen0_prog47": {
        "id": "generic_shortest_path_problem_gen0_prog47",
        "code": "def solve_shortest_paths(args):\n    import heapq\n\n    if not isinstance(args, (list, tuple)) or len(args) != 2:\n        return None\n\n    graph, start = args\n\n    if not isinstance(graph, dict):\n        return None\n\n    nodes = set(graph.keys())\n    for u in graph.values():\n        if isinstance(u, dict):\n            nodes.update(u.keys())\n    nodes.add(start)\n\n    adj = {}\n    for n in nodes:\n        edges = graph.get(n, {})\n        if isinstance(edges, dict):\n            adj[n] = edges\n        else:\n            adj[n] = {}\n\n    INF = float('inf')\n    dist = {n: INF for n in nodes}\n    dist[start] = 0\n\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u].items():\n            nd = d + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n\n    result = {}\n    for n in nodes:\n        if dist[n] == INF:\n            result[n] = \"float('inf')\"\n        else:\n            result[n] = dist[n]\n\n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Execution failed with exit code 126. Docker error: 'docker: permission denied while trying to connect to the docker API at unix:///var/run/docker.sock\n\nRun 'docker run --help' for more information'"
        ],
        "status": "failed_evaluation",
        "created_at": 1762963372.3846955,
        "task_id": null,
        "fitness": null,
        "metrics": {},
        "prompt_id": null
    },
    "generic_shortest_path_problem_gen1_child2_0": {
        "id": "generic_shortest_path_problem_gen1_child2_0",
        "code": "def solve_shortest_paths(*args):\n    import heapq\n\n    # Normalize inputs to (graph, start, cfg)\n    graph = {}\n    start = None\n    cfg = {}\n\n    # Support both single container arg and variadic args\n    if len(args) == 1 and isinstance(args[0], (list, tuple)):\n        arglist = args[0]\n    else:\n        arglist = list(args)\n\n    if not arglist or len(arglist) < 2:\n        return {}\n\n    # Extract graph and start\n    g = arglist[0]\n    if isinstance(g, dict):\n        graph = g\n    else:\n        # Defensive: if graph is not a dict, treat as empty graph\n        graph = {}\n\n    start = arglist[1]\n\n    # Optional configuration\n    if len(arglist) >= 3 and isinstance(arglist[2], dict):\n        cfg = arglist[2]\n    else:\n        cfg = {}\n\n    # Configuration options\n    max_relaxations = cfg.get(\"max_relaxations\", None)\n    max_pops = cfg.get(\"max_pops\", None)\n\n    # No-op logger by default\n    log_fn = cfg.get(\"log_fn\", None)\n    def log(*_a, **_k):\n        if callable(log_fn):\n            try:\n                log_fn(*_a, **_k)\n            except Exception:\n                pass\n\n        # Collect all nodes (including implicit ones and the start)\n    nodes = set()\n    if isinstance(graph, dict):\n        try:\n            nodes.update(graph.keys())\n        except Exception:\n            pass\n        for u in graph:\n            neighbors = graph.get(u, {})\n            if isinstance(neighbors, dict):\n                for k in neighbors.keys():\n                    try:\n                        hash(k)\n                    except Exception:\n                        continue\n                    nodes.add(k)\n    # Include start node if hashable\n    try:\n        hash(start)\n        nodes.add(start)\n    except Exception:\n        # Unhashable start; cannot compute paths\n        return {}\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0.0, start)]\n    relaxations = 0\n    pops = 0\n\n        while heap:\n        try:\n            d, u = heapq.heappop(heap)\n        except Exception:\n            # Heap corruption or unexpected content; abort safely\n            break\n        pops += 1\n        if max_pops is not None and pops > max_pops:\n            break\n        # Skip if this entry is stale or if u is unknown\n        if d > dist.get(u, float('inf')):\n            continue\n        # Traverse neighbors defensively\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        for v, w in nbrs.items():\n            # Ensure neighbor key is hashable\n            try:\n                hash(v)\n            except Exception:\n                continue\n            # Parse weight\n            try:\n                weight = float(w)\n            except Exception:\n                # If weight is not a number, skip this edge\n                continue\n            # Skip NaN weights\n            if weight != weight:\n                continue\n            nd = d + weight\n            if nd < dist.get(v, float('inf')):\n                dist[v] = nd\n                try:\n                    heapq.heappush(heap, (nd, v))\n                except Exception:\n                    # If push fails, continue without adding\n                    pass\n                relaxations += 1\n                if max_relaxations is not None and relaxations > max_relaxations:\n                    log(\"Relaxation budget exceeded; returning partial results.\")\n                    heap = []\n                    break\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog5",
        "island_id": 5,
        "errors": [
            "SyntaxError: unexpected indent at line 80, offset 8"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395776.383573,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen1_child2_1": {
        "id": "generic_shortest_path_problem_gen1_child2_1",
        "code": "def solve_shortest_paths(args):\n    import heapq\n\n    # Parse inputs\n    graph = {}\n    start = None\n    cfg = {}\n\n    if isinstance(args, dict):\n        graph = args.get(\"graph\", {})\n        start = args.get(\"start\", args.get(\"source\", args.get(\"start_node\")))\n        cfg = args.get(\"cfg\", args.get(\"config\", {})) or {}\n    elif isinstance(args, (list, tuple)):\n        if len(args) >= 1 and isinstance(args[0], dict):\n            graph = args[0]\n        if len(args) >= 2:\n            start = args[1]\n        if len(args) >= 3 and isinstance(args[2], dict):\n            cfg = args[2]\n    else:\n        return {}\n    # Validate inputs\n    if not isinstance(graph, dict) or start is None:\n        return {}\n    max_relaxations = cfg.get(\"max_relaxations\", None)\n    max_pops = cfg.get(\"max_pops\", None)\n    # No-op logger by default\n    log_fn = cfg.get(\"log_fn\", None)\n    def log(*_a, **_k):\n        if callable(log_fn):\n            try:\n                log_fn(*_a, **_k)\n            except Exception:\n                pass\n\n    # Collect all nodes (including implicit ones and the start)\n    nodes = set(graph.keys())\n    for u in graph:\n        neighbors = graph.get(u, {})\n        if isinstance(neighbors, dict):\n            nodes.update(neighbors.keys())\n    nodes.add(start)\n\n    # Initialize distances\n    dist = {node: float('inf') for node in nodes}\n    dist[start] = 0.0\n\n    # Dijkstra's algorithm using a min-heap\n    heap = [(0.0, start)]\n    relaxations = 0\n    pops = 0\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        pops += 1\n        if max_pops is not None and pops > max_pops:\n            break\n        # Skip if this entry is stale\n        if d != dist[u]:\n            continue\n                # Traverse neighbors\n        for v, w in graph.get(u, {}).items():\n            try:\n                weight = float(w)\n            except Exception:\n                # If weight is not a number, skip this edge\n                continue\n            # Skip NaN or infinite weights to avoid corrupting distances\n            if weight != weight or weight == float('inf') or weight == float('-inf'):\n                continue\n            # Ensure unseen nodes are tracked\n            if v not in dist:\n                dist[v] = float('inf')\n            nd = d + weight\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(heap, (nd, v))\n                relaxations += 1\n                if max_relaxations is not None and relaxations > max_relaxations:\n                    log(\"Relaxation budget exceeded; returning partial results.\")\n                    heap = []\n                    break\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog5",
        "island_id": 5,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763395780.9642367,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen2_child2_0": {
        "id": "generic_shortest_path_problem_gen2_child2_0",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n    # Unpack inputs with optional config\n    if isinstance(input_data, (list, tuple)) and len(input_data) >= 2:\n        graph = input_data[0] if input_data[0] is not None else {}\n        start = input_data[1]\n        cfg_in = input_data[2] if len(input_data) > 2 and isinstance(input_data[2], dict) else {}\n    elif isinstance(input_data, dict):\n        # Support dict-based input formats\n        if \"graph\" in input_data or \"start\" in input_data or \"source\" in input_data:\n            graph = input_data.get(\"graph\", {}) or input_data.get(\"edges\", {}) or input_data.get(\"adjacency\", {})\n            start = input_data.get(\"start\", input_data.get(\"source\", input_data.get(\"start_node\")))\n            cfg_in = input_data.get(\"config\") or input_data.get(\"cfg\") or {}\n            if not isinstance(cfg_in, dict):\n                cfg_in = {}\n        else:\n            # Interpret the input itself as the graph; no start provided\n            graph = input_data\n            start = None\n            cfg_in = {}\n    else:\n        graph = {}\n        start = None\n        cfg_in = {}\n\n    # Configuration knobs and resource budgets\n    config = {\n        \"log_enabled\": False,\n        \"max_expansions\": None,     # Max node pops to expand\n        \"max_relaxations\": None     # Max successful edge relaxations\n    }\n    config.update({k: v for k, v in cfg_in.items() if k in config and v is not None})\n\n    # Lightweight logger\n    def make_logger(enabled=False):\n        logs = []\n        def log(event, **kwargs):\n            if enabled:\n                logs.append((event, kwargs))\n        return log\n    log = make_logger(config[\"log_enabled\"])\n\n    # Normalize graph\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Gather all nodes, including implicit ones and the start node\n    all_nodes = set()\n    for u, nbrs in graph.items():\n        all_nodes.add(u)\n        if isinstance(nbrs, dict):\n            all_nodes.update(nbrs.keys())\n    if start is not None:\n        all_nodes.add(start)\n\n    # If no start provided, there's nothing meaningful to compute\n    if start is None:\n        return {}\n\n    # Distances initialization\n    INF = float('inf')\n    dist = {node: INF for node in all_nodes}\n    dist[start] = 0\n\n    # Neighbor access with simple caching\n    neighbors_cache = {}\n    def get_neighbors(u):\n        if u in neighbors_cache:\n            return neighbors_cache[u]\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        neighbors_cache[u] = nbrs\n        return nbrs\n\n        # Dijkstra's algorithm with heap\n    push_id = 0\n    heap = [(0, 0, start)]\n    settled = set()\n\n    expansions = 0\n    relaxations = 0\n\n        while heap:\n        d, _, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        if u not in settled:\n            settled.add(u)\n        # Resource budget: expansions\n        if config[\"max_expansions\"] is not None and expansions >= config[\"max_expansions\"]:\n            break\n        expansions += 1\n\n        for v, w in get_neighbors(u).items():\n            try:\n                new_d = d + w\n            except Exception:\n                # Skip edges with invalid weights\n                continue\n                        if new_d < dist[v]:\n                # Resource budget: relaxations\n                if config[\"max_relaxations\"] is not None and relaxations >= config[\"max_relaxations\"]:\n                    continue\n                dist[v] = new_d\n                relaxations += 1\n                push_id += 1\n                heapq.heappush(heap, (new_d, push_id, v))\n\n    # Ensure all nodes present; if graph was empty, at least include start\n    if start not in dist:\n        dist[start] = 0\n\n    # Log final stats (kept internal)\n    log(\"done\", expansions=expansions, relaxations=relaxations, settled=len(settled))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog3",
        "island_id": 3,
        "errors": [
            "SyntaxError: unexpected indent at line 85, offset 8"
        ],
        "status": "failed_evaluation",
        "created_at": 1763396090.2335782,
        "task_id": "generic_shortest_path_problem",
        "fitness": null,
        "metrics": {},
        "prompt_id": "stability_guard"
    },
    "generic_shortest_path_problem_gen2_child2_1": {
        "id": "generic_shortest_path_problem_gen2_child2_1",
        "code": "def solve_shortest_paths(input_data):\n    import heapq\n\n    # Unpack inputs with optional config\n    graph = {}\n    start = None\n    cfg_in = {}\n    if isinstance(input_data, (list, tuple)) and len(input_data) >= 2:\n        graph = input_data[0] if input_data[0] is not None else {}\n        start = input_data[1]\n        cfg_in = input_data[2] if len(input_data) > 2 and isinstance(input_data[2], dict) else {}\n    elif isinstance(input_data, dict):\n        # Support dict-based inputs: {\"graph\": ..., \"start\": ..., \"config\": {...}}\n        if \"graph\" in input_data or \"start\" in input_data or \"source\" in input_data:\n            graph = input_data.get(\"graph\", {})\n            start = input_data.get(\"start\", input_data.get(\"source\"))\n            cfg_in = input_data.get(\"config\", {})\n        else:\n            # If a plain graph dict is provided, treat it as the graph\n            graph = input_data\n    else:\n        # Fallback defaults if input does not match expected structures\n        graph = {}  # keep empty\n        start = None\n        cfg_in = {}\n\n    # Configuration knobs and resource budgets\n    config = {\n        \"log_enabled\": False,\n        \"max_expansions\": None,     # Max node pops to expand\n        \"max_relaxations\": None     # Max successful edge relaxations\n    }\n    config.update({k: v for k, v in cfg_in.items() if k in config and v is not None})\n\n    # Lightweight logger\n    def make_logger(enabled=False):\n        logs = []\n        def log(event, **kwargs):\n            if enabled:\n                logs.append((event, kwargs))\n        return log\n    log = make_logger(config[\"log_enabled\"])\n\n    # Normalize graph\n    if not isinstance(graph, dict):\n        graph = {}\n\n    # Gather all nodes, including implicit ones and the start node\n    all_nodes = set()\n    for u, nbrs in graph.items():\n        all_nodes.add(u)\n        if isinstance(nbrs, dict):\n            all_nodes.update(nbrs.keys())\n    if start is not None:\n        all_nodes.add(start)\n\n    # If no start provided, there's nothing meaningful to compute\n    if start is None:\n        return {}\n\n        # Distances initialization\n    INF = float('inf')\n    dist = {node: INF for node in all_nodes}\n    dist[start] = 0\n\n    # Detect negative weight edges and fallback to Bellman-Ford if present\n    edges = []\n    has_negative = False\n    try:\n        for u, nbrs in graph.items():\n            if isinstance(nbrs, dict):\n                for v, w in nbrs.items():\n                    # Only consider numeric weights; skip invalid ones\n                    if isinstance(w, (int, float)):\n                        val = w\n                    else:\n                        try:\n                            val = float(w)\n                        except Exception:\n                            continue\n                    # Skip NaN weights\n                    if val != val:\n                        continue\n                    if val < 0:\n                        has_negative = True\n                    edges.append((u, v, val))\n    except Exception:\n        # If graph structure is unexpected, fall back to empty edges\n        edges = []\n        has_negative = False\n\n    if has_negative:\n        # Bellman-Ford for graphs with negative weights\n        n = len(all_nodes)\n        for _ in range(n - 1):\n            updated = False\n            for u, v, w in edges:\n                if dist[u] != INF and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    updated = True\n            if not updated:\n                break\n        # Ensure the start is present even if all_nodes was empty\n        if start not in dist:\n            dist[start] = 0\n        log(\"done\", expansions=0, relaxations=0, settled=0)\n        return dist\n\n    # Neighbor access with simple caching\n    neighbors_cache = {}\n    def get_neighbors(u):\n        if u in neighbors_cache:\n            return neighbors_cache[u]\n        nbrs = graph.get(u, {})\n        if not isinstance(nbrs, dict):\n            nbrs = {}\n        neighbors_cache[u] = nbrs\n        return nbrs\n\n    # Dijkstra's algorithm with heap\n    heap = [(0, start)]\n    settled = set()\n\n    expansions = 0\n    relaxations = 0\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d > dist[u]:\n            continue\n        if u not in settled:\n            settled.add(u)\n        # Resource budget: expansions\n        if config[\"max_expansions\"] is not None and expansions >= config[\"max_expansions\"]:\n            break\n        expansions += 1\n\n        for v, w in get_neighbors(u).items():\n            try:\n                new_d = d + w\n            except Exception:\n                # Skip edges with invalid weights\n                continue\n            if new_d < dist[v]:\n                # Resource budget: relaxations\n                if config[\"max_relaxations\"] is not None and relaxations >= config[\"max_relaxations\"]:\n                    continue\n                dist[v] = new_d\n                relaxations += 1\n                heapq.heappush(heap, (new_d, v))\n\n    # Ensure all nodes present; if graph was empty, at least include start\n    if start not in dist:\n        dist[start] = 0\n\n    # Log final stats (kept internal)\n    log(\"done\", expansions=expansions, relaxations=relaxations, settled=len(settled))\n\n    return dist",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog3",
        "island_id": 3,
        "errors": [
            "Failed 8 of 8 tests at Level 0 ('weighted_graph_examples')."
        ],
        "status": "failed_evaluation",
        "created_at": 1763396073.9259453,
        "task_id": "generic_shortest_path_problem",
        "fitness": 0.0,
        "metrics": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 8.0,
            "highest_level_passed": -1.0
        },
        "prompt_id": "stability_guard"
    },
    "j_investment_strategy_gen0_prog0": {
        "id": "j_investment_strategy_gen0_prog0",
        "code": "I\u2019m doing well, thanks for asking! How are you today? What can I help you with?",
        "fitness_scores": {},
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [
            "SyntaxError: invalid character '\u2019' (U+2019) at line 1, offset 2"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395249.9117906,
        "task_id": "j_investment_strategy",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "heuristic_inventor"
    },
    "j_investment_strategy_gen0_prog1": {
        "id": "j_investment_strategy_gen0_prog1",
        "code": "Hi! I'm doing well, thanks for asking. How can I help you today?",
        "fitness_scores": {},
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "SyntaxError: unterminated string literal (detected at line 1) at line 1, offset 6"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395249.9148161,
        "task_id": "j_investment_strategy",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "heuristic_inventor"
    },
    "j_investment_strategy_gen0_prog2": {
        "id": "j_investment_strategy_gen0_prog2",
        "code": "I\u2019m doing well, thanks for asking! How are you? What can I help you with today?",
        "fitness_scores": {},
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "SyntaxError: invalid character '\u2019' (U+2019) at line 1, offset 2"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395249.917655,
        "task_id": "j_investment_strategy",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "heuristic_inventor"
    },
    "j_investment_strategy_gen0_prog3": {
        "id": "j_investment_strategy_gen0_prog3",
        "code": "Hi! I\u2019m doing well, thanks for asking. How can I help you today?",
        "fitness_scores": {},
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "SyntaxError: invalid character '\u2019' (U+2019) at line 1, offset 6"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395249.92046,
        "task_id": "j_investment_strategy",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "heuristic_inventor"
    },
    "j_investment_strategy_gen0_prog4": {
        "id": "j_investment_strategy_gen0_prog4",
        "code": "I\u2019m doing well, thanks for asking! How can I help you today?",
        "fitness_scores": {},
        "generation": 0,
        "parent_id": null,
        "island_id": 4,
        "errors": [
            "SyntaxError: invalid character '\u2019' (U+2019) at line 1, offset 2"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395249.9232192,
        "task_id": "j_investment_strategy",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "heuristic_inventor"
    },
    "j_investment_strategy_gen0_prog5": {
        "id": "j_investment_strategy_gen0_prog5",
        "code": "I\u2019m doing well, thanks for asking! How are you? What can I help you with today?",
        "fitness_scores": {},
        "generation": 0,
        "parent_id": null,
        "island_id": 5,
        "errors": [
            "SyntaxError: invalid character '\u2019' (U+2019) at line 1, offset 2"
        ],
        "status": "failed_evaluation",
        "created_at": 1763395249.9259732,
        "task_id": "j_investment_strategy",
        "fitness": 0.0,
        "metrics": {},
        "prompt_id": "heuristic_inventor"
    }
}